<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.35" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html"><meta property="og:site_name" content="疼了也不哭"><meta property="og:title" content="程序编译与优化"><meta property="og:description" content="一、前端编译与优化 原文链接：https://gaoyubo.cn/blogs/89d6d9be.html Java技术下讨论“编译期”需要结合具体上下文语境，因为它可能存在很多种情况： 前端编译器（叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程 JDK的Javac、Eclipse JDT中的增量式编译器（ECJ） 即时编译..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="Mr.Hope"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"程序编译与优化","image":[""],"dateModified":null,"author":[{"@type":"Person","name":"Mr.Hope","url":"https://mister-hope.com"}]}</script><title>程序编译与优化 | 疼了也不哭</title><meta name="description" content="一、前端编译与优化 原文链接：https://gaoyubo.cn/blogs/89d6d9be.html Java技术下讨论“编译期”需要结合具体上下文语境，因为它可能存在很多种情况： 前端编译器（叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程 JDK的Javac、Eclipse JDT中的增量式编译器（ECJ） 即时编译...">
    <link rel="preload" href="/assets/style-DPI_gByq.css" as="style"><link rel="stylesheet" href="/assets/style-DPI_gByq.css">
    <link rel="modulepreload" href="/assets/app-D1py-eEI.js"><link rel="modulepreload" href="/assets/JVM学习-程序编译与优化.html-DP3E_bg7.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-DitktZPW.js" as="script"><link rel="prefetch" href="/assets/disable.html-Be1SAc7n.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-DKA14yfk.js" as="script"><link rel="prefetch" href="/assets/layout.html-hVFbB8iz.js" as="script"><link rel="prefetch" href="/assets/markdown.html-Cg69bxdL.js" as="script"><link rel="prefetch" href="/assets/page.html-D-RhWfiA.js" as="script"><link rel="prefetch" href="/assets/index.html-CeTChrPf.js" as="script"><link rel="prefetch" href="/assets/my1.html-CAf2EyGD.js" as="script"><link rel="prefetch" href="/assets/my2.html-ubVU3jae.js" as="script"><link rel="prefetch" href="/assets/index.html-Bvubzp2V.js" as="script"><link rel="prefetch" href="/assets/JVM学习-Class文件结构.html-Ck4kusef.js" as="script"><link rel="prefetch" href="/assets/JVM学习-字节码执行引擎.html-57A4p7fY.js" as="script"><link rel="prefetch" href="/assets/JVM学习-类加载机制.html-C15piYw-.js" as="script"><link rel="prefetch" href="/assets/JVM学习-自动内存管理.html-BJdten6y.js" as="script"><link rel="prefetch" href="/assets/Gin框架笔记.html-CnPuoNJg.js" as="script"><link rel="prefetch" href="/assets/配置GOPATH.html-BEg8QVqd.js" as="script"><link rel="prefetch" href="/assets/数据库表自动生成CRUD.html-CLgnd21z.js" as="script"><link rel="prefetch" href="/assets/Lambda表达式.html-DqjFl0IT.js" as="script"><link rel="prefetch" href="/assets/Optional类.html-BDmOQTbV.js" as="script"><link rel="prefetch" href="/assets/函数式接口.html-KQ66JxTr.js" as="script"><link rel="prefetch" href="/assets/接口增强.html-VriBnpV4.js" as="script"><link rel="prefetch" href="/assets/@Configuration 和 @Component 的详细区别.html-oPwr5VzL.js" as="script"><link rel="prefetch" href="/assets/@ConfigurationProperties和@EnableConfigurationProperties的使用.html-VnCVhji8.js" as="script"><link rel="prefetch" href="/assets/@EnableAutoConfiguration自动装配.html-B1LLgTTM.js" as="script"><link rel="prefetch" href="/assets/yml文件字符串、List、Map的书写方式并使用@ConfigurationProperties注入配置类.html-kyhpZKEj.js" as="script"><link rel="prefetch" href="/assets/Window杀死端口号.html-D135DrXX.js" as="script"><link rel="prefetch" href="/assets/项目初始化.html-OksHw1PB.js" as="script"><link rel="prefetch" href="/assets/指令和指令集.html-DCt9GBsG.js" as="script"><link rel="prefetch" href="/assets/指令实现.html-CvS7u5KR.js" as="script"><link rel="prefetch" href="/assets/准备环境.html-BECfY4dz.js" as="script"><link rel="prefetch" href="/assets/编写命令行工具.html-CbnZwrRV.js" as="script"><link rel="prefetch" href="/assets/获取类路径.html-5PYW9sTn.js" as="script"><link rel="prefetch" href="/assets/解析Class文件.html-CwXzq-SJ.js" as="script"><link rel="prefetch" href="/assets/实现运行时数据区.html-Bq9Mao2n.js" as="script"><link rel="prefetch" href="/assets/局部变量表和操作数栈实例分析.html-B51dnKTr.js" as="script"><link rel="prefetch" href="/assets/数据类型概述.html-CnmCeG5U.js" as="script"><link rel="prefetch" href="/assets/测试.html-F20TiQOI.js" as="script"><link rel="prefetch" href="/assets/运行时数据区概述.html-B7jfH2xZ.js" as="script"><link rel="prefetch" href="/assets/常用方法.html-B6BhYfK4.js" as="script"><link rel="prefetch" href="/assets/并行流.html-zdEuKq3Q.js" as="script"><link rel="prefetch" href="/assets/结果收集.html-BwnGCbg0.js" as="script"><link rel="prefetch" href="/assets/综合案例.html-TCcEo5qr.js" as="script"><link rel="prefetch" href="/assets/获取方式.html-BI0Bmuv-.js" as="script"><link rel="prefetch" href="/assets/抽象工厂.html-CuSuAGE0.js" as="script"><link rel="prefetch" href="/assets/生成器.html-CEqrH_F1.js" as="script"><link rel="prefetch" href="/assets/抽象工厂.html-DUrw0hkX.js" as="script"><link rel="prefetch" href="/assets/桥接.html-B3Ey6_ul.js" as="script"><link rel="prefetch" href="/assets/生成器.html-70fSrJtf.js" as="script"><link rel="prefetch" href="/assets/策略模式.html-BO8NL_MQ.js" as="script"><link rel="prefetch" href="/assets/装饰器.html-BSmqzjgO.js" as="script"><link rel="prefetch" href="/assets/观察者.html-u4UhfdzL.js" as="script"><link rel="prefetch" href="/assets/适配器.html-DMkwxgIK.js" as="script"><link rel="prefetch" href="/assets/桥接.html-BR6ZZELA.js" as="script"><link rel="prefetch" href="/assets/装饰器.html-BbRgpmnX.js" as="script"><link rel="prefetch" href="/assets/适配器.html-B3ptqRgU.js" as="script"><link rel="prefetch" href="/assets/策略模式.html-ghh1T9N2.js" as="script"><link rel="prefetch" href="/assets/观察者.html-DrhEKwJN.js" as="script"><link rel="prefetch" href="/assets/404.html-m_nuoi--.js" as="script"><link rel="prefetch" href="/assets/index.html-Cv9_mBK4.js" as="script"><link rel="prefetch" href="/assets/index.html-DR0GGA5h.js" as="script"><link rel="prefetch" href="/assets/index.html-DnDDnECx.js" as="script"><link rel="prefetch" href="/assets/index.html-DyuN0RSj.js" as="script"><link rel="prefetch" href="/assets/index.html-B56PCvWS.js" as="script"><link rel="prefetch" href="/assets/index.html-raCW14iD.js" as="script"><link rel="prefetch" href="/assets/index.html-DsVN6-n-.js" as="script"><link rel="prefetch" href="/assets/index.html-BftcthEo.js" as="script"><link rel="prefetch" href="/assets/index.html-BvweaVHS.js" as="script"><link rel="prefetch" href="/assets/index.html-Cv96N_Zm.js" as="script"><link rel="prefetch" href="/assets/index.html-BQXnCBgX.js" as="script"><link rel="prefetch" href="/assets/index.html-63RusI7U.js" as="script"><link rel="prefetch" href="/assets/index.html-CBDEPXRi.js" as="script"><link rel="prefetch" href="/assets/index.html-DBD7Wa23.js" as="script"><link rel="prefetch" href="/assets/index.html-ClyyBrWk.js" as="script"><link rel="prefetch" href="/assets/index.html-CaZGxY8O.js" as="script"><link rel="prefetch" href="/assets/index.html-BAkZ0DZk.js" as="script"><link rel="prefetch" href="/assets/index.html-CNAzigKH.js" as="script"><link rel="prefetch" href="/assets/index.html-Dd9gClEy.js" as="script"><link rel="prefetch" href="/assets/index.html-D8CDkSKg.js" as="script"><link rel="prefetch" href="/assets/index.html-q148AIJ7.js" as="script"><link rel="prefetch" href="/assets/giscus-7BMGhbDA.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-SzV8tJDW.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="https://theme-hope-assets.vuejs.press/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">疼了也不哭</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/guide/" aria-label="笔记"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>笔记<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link active" href="/book/" aria-label="书籍"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>书籍<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/my/" aria-label="我的"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>我的<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/recommend/" aria-label="推荐"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>推荐<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link nav-link" href="/project/" aria-label="项目"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span>项目<!----></a></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">深入理解 Java虚拟机</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" aria-label="程序编译与优化"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>程序编译与优化<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" aria-label="类加载机制"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>类加载机制<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html" aria-label="文件结构"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>文件结构<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html" aria-label="字节码执行引擎"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>字节码执行引擎<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html" aria-label="自动内存管理"><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>自动内存管理<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">Go实现 Java虚拟机</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span>程序编译与优化</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://mister-hope.com" target="_blank" rel="noopener noreferrer">Mr.Hope</a></span><span property="author" content="Mr.Hope"></span></span><!----><!----><span class="page-pageview-info" aria-label="访问量🔢" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon eye-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="eye icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 00-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z"></path></svg><span id="ArtalkPV" class="vp-pageview waline-pageview-count" data-path="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html" data-page-key="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html">...</span></span><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 26 分钟</span><meta property="timeRequired" content="PT26M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_1-1javac编译器">1.1Javac编译器</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#解析和填充符号表">解析和填充符号表</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#填充符号表">填充符号表</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#注解处理器">注解处理器</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#语义分析与字节码生成">语义分析与字节码生成</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_1-2语法糖的本质">1.2语法糖的本质</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#泛型">泛型</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-1即时编译器">2.1即时编译器</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#编译对象与触发条件">编译对象与触发条件</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#编译过程">编译过程</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-2提前编译器">2.2提前编译器</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_2-3即时编译器的优势">2.3即时编译器的优势</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_3-1一个优化的例子">3.1一个优化的例子</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_3-2方法内联">3.2方法内联</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_3-3逃逸分析【最前沿】">3.3逃逸分析【最前沿】</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#例子">例子</a></li><!----><!--]--></ul></li><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="一、前端编译与优化" tabindex="-1"><a class="header-anchor" href="#一、前端编译与优化"><span>一、前端编译与优化</span></a></h1><p>原文链接：<a href="https://gaoyubo.cn/blogs/89d6d9be.html" target="_blank" rel="noopener noreferrer">https://gaoyubo.cn/blogs/89d6d9be.html<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>Java技术下讨论“编译期”需要结合具体上下文语境，因为它可能存在很多种情况：</p><ul><li><p>前端编译器（叫“编译器的前端”更准确一些）把<code>.java文件</code>转变成<code>.class文件</code>的过程</p><p>JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</p></li><li><p>即时编译器（常称JIT编译器，Just In Time Compiler）运行期<strong>把字节码转变成本地机器码</strong>的过程</p><p>HotSpot虚拟机的C1、C2编译器，Graal编译器</p></li><li><p>提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接<strong>把程序编译成与目标机器指令集相关的二进制代码</strong>的过程</p><p>JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET 。</p></li></ul><p>本章标题中的“前端”指的是由<strong>前端编译器</strong>完成的编译行为，对于前端编译优化，有以下说法：</p><ol><li><p>前端编译器对代码的运行效率几乎没有任何优化措施可言</p></li><li><p>Java虚拟机设计团队选择把对<strong>性能的优化全部集中到运行期的即时编译器</strong>中</p><p>这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化措施所带来的性能红利</p></li><li><p>相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者Java虚拟机的底层改进来支持。</p></li><li><p>Java中即时编译器在运行期的优化过程，支撑了程序执行效率的不断提升；</p></li><li><p>前端编译器在编译期的优化过程，支撑着程序员的编码效率和语言使用者的幸福感的提高</p></li></ol><h2 id="_1-1javac编译器" tabindex="-1"><a class="header-anchor" href="#_1-1javac编译器"><span>1.1Javac编译器</span></a></h2><p>从Javac源代码的总体结构来看，编译过程大致可以分为<strong>1个准备过程和3个处理过程</strong>，它们分别如下所示：</p><ol><li><p>准备过程：初始化插入式注解处理器</p></li><li><p>解析与填充符号表过程，包括：</p><p>​ 词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树</p><p>​ 填充符号表：产生符号地址和符号信息</p></li><li><p>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段</p></li><li><p>分析与字节码生成过程，包括：</p><p>标注检查：对语法的静态信息进行检查。</p><p>数据流及控制流分析：对程序动态运行过程进行检查。</p><p>解语法糖：将简化代码编写的语法糖还原为原有的形式。</p><p>字节码生成：将前面各个步骤所生成的信息转化成字节码。</p></li><li><p>对于以上过程：执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转 回到之前的解析、填充符号表的过程中重新处理这些新符号</p></li><li><p>整个编译过程主要的处理由图中标注的8个方法来完成</p></li></ol><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/23/bb75abafae4575a1341040b2903f13ab.png" style="zoom:50%;"><h3 id="解析和填充符号表" tabindex="-1"><a class="header-anchor" href="#解析和填充符号表"><span>解析和填充符号表</span></a></h3><h4 id="词法语法分析" tabindex="-1"><a class="header-anchor" href="#词法语法分析"><span>词法语法分析</span></a></h4><p><strong>1.词法分析</strong>：词法分析是将源代码的字符流转变为标记（Token）集合的过程。</p><p><strong>2.语法分析</strong>：语法分析是根据标记序列构造抽象语法树的过程</p><ul><li><p>抽象语法树：抽象语法树（Abstract Syntax Tree，AST）是一 种用来<strong>描述程序代码语法结构的树形表示方式</strong>，抽象语法树的每一个节点都代表着程序代码中的一个语法结构</p></li><li><p>包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</p></li><li><p>抽象语法树可通过Eclipse AST View插件查看，抽象语法树是以com.sun.tools.javac.tree.JCTree 类表示的</p></li><li><p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，<strong>后续的操作都建立在抽象语法树之上</strong></p></li></ul><h3 id="填充符号表" tabindex="-1"><a class="header-anchor" href="#填充符号表"><span>填充符号表</span></a></h3><p>符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构（可以理解成哈希表中的键值对的存储形式）</p><p>符号表中所登记的信息在编译的不同阶段都要被用到：</p><ul><li>语义分析的过程中，符号表所登记的内容将用于语义检查 （如检查一个名字的使用和原先的声明是否一致）和产生中间代码</li><li>目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</li></ul><h3 id="注解处理器" tabindex="-1"><a class="header-anchor" href="#注解处理器"><span><strong>注解处理器</strong></span></a></h3><p>可以把<strong>插入式注解处理器</strong>看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。</p><p>譬如Java著名的编码效率工具Lombok，它可以通过注解来实现自动产生 getter/setter方法、进行空置检查、生成受查异常表、产生equals()和hashCode()方法，等等.</p><h3 id="语义分析与字节码生成" tabindex="-1"><a class="header-anchor" href="#语义分析与字节码生成"><span>语义分析与字节码生成</span></a></h3><p>语义分析的主要任务则是对结构上正确的源 程序进行上下文相关性质的检查，譬如进行<strong>类型检查、控制流检查、数据流检查</strong>，等等</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">//后续可能出现的赋值运算：</span>

<span class="token keyword">int</span> d <span class="token operator">=</span> a <span class="token operator">+</span> c<span class="token punctuation">;</span> 
<span class="token keyword">int</span> d <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span> <span class="token comment">//错误，</span>
<span class="token keyword">char</span> d <span class="token operator">=</span> a <span class="token operator">+</span> c<span class="token punctuation">;</span> <span class="token comment">//错误</span>

<span class="token comment">//C语言中，a、b、c的上下文定义不变，第二、三种写法都是可以被正确编译的</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>我们编码时经常能在IDE 中看到由红线标注的错误提示，其中绝大部分都是来源于语义分析阶段的检查结果。</p></blockquote><h4 id="_1-标注检查" tabindex="-1"><a class="header-anchor" href="#_1-标注检查"><span>1.标注检查</span></a></h4><p>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等，刚才3个变量定义的例子就属于标注检查的处理范畴</p><p>在标注检查中，还会顺便进行 一个称为常量折叠（Constant Folding）的代码优化，这是Javac编译器会对源代码做的极少量优化措施 之一（代码优化几乎都在即时编译器中进行）。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>int a = 2 + 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/23/3d5879de02d9a355c9c9f4b06576e61d.png" style="zoom:67%;"><blockquote><p>由于编译期间进行了常量折叠，所以在代码里面定 义“a=1+2”比起直接定义“a=3”来，并不会增加程序运行期哪怕仅仅一个处理器时钟周期的处理工作量。</p></blockquote><h4 id="_2-数据及控制流分析" tabindex="-1"><a class="header-anchor" href="#_2-数据及控制流分析"><span>2.数据及控制流分析</span></a></h4><p>可以检查出诸如程序局部变量 <strong>在使用前是否有赋值</strong>、方法的<strong>每条路径是否都有返回值</strong>、是否所有的受查异常都被正确处理了等问题。</p><h4 id="_3-解语法糖" tabindex="-1"><a class="header-anchor" href="#_3-解语法糖"><span>3.解语法糖</span></a></h4><p>在Javac的源码中，解语法糖的过程由desugar()方法触发。</p><blockquote><p>Java中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱，等等。</p></blockquote><h4 id="_4-字节码生成" tabindex="-1"><a class="header-anchor" href="#_4-字节码生成"><span>4.字节码生成</span></a></h4><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。</p><p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p><blockquote><p>实例构造器()方法和类构造器()方法就是在这个阶段被添加到语 法树之中的</p><p>字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 5）的append()操 作，等等。</p></blockquote><h2 id="_1-2语法糖的本质" tabindex="-1"><a class="header-anchor" href="#_1-2语法糖的本质"><span>1.2语法糖的本质</span></a></h2><h3 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型"><span>泛型</span></a></h3><p>泛型的本质是参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数。</p><p>Java选择的泛型实现方式叫作<code>类型擦除式泛型</code>：Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的<strong>裸类型</strong>了，并且在相应的地方插入了强制转型代码。</p><h4 id="类型擦除" tabindex="-1"><a class="header-anchor" href="#类型擦除"><span>类型擦除</span></a></h4><p><strong>裸类型”</strong>（Raw Type）的概念：裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ilist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> slist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span> list<span class="token punctuation">;</span> <span class="token comment">// 裸类型</span>
list <span class="token operator">=</span> ilist<span class="token punctuation">;</span>
list <span class="token operator">=</span> slist<span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如何实现裸类型？</strong></p><p>直接在编译时把<code>ArrayList&lt;Integer&gt;</code>通过类型擦除还原回ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令</p><p>泛型擦除前的例子</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;吃了没？&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//裸类型</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;吃了没？&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//强制类型转换</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>当泛型遇到重载</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypes</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;String&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数列表在<a href="https://gaoyubo.cn/blogs/844dc0e7.html?highlight=%E7%89%B9%E5%BE%81%E7%AD%BE%E5%90%8D#class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%A4%BA%E4%BE%8B-2" target="_blank" rel="noopener noreferrer">特征签名<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>中，因此参数列表不同时，可以进行重载，但是由于所有泛型都需要通过类型擦出转化为裸类型，导致参数都是<code>List list</code>，所以不能重载。会报错。</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/23/c22f3050c01be15744d8b6ad77419ab6.png" style="zoom:50%;"><h4 id="自动装箱、拆箱与遍历循环" tabindex="-1"><a class="header-anchor" href="#自动装箱、拆箱与遍历循环"><span>自动装箱、拆箱与遍历循环</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span> localIterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> localIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>localIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="二、后端编译与优化" tabindex="-1"><a class="header-anchor" href="#二、后端编译与优化"><span>二、后端编译与优化</span></a></h1><p>如果把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话， 那编译器无论在何时、在何种状态下把<strong>Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码</strong>，都可以视为整个编译过程的后端</p><h2 id="_2-1即时编译器" tabindex="-1"><a class="header-anchor" href="#_2-1即时编译器"><span>2.1即时编译器</span></a></h2><p>由于<strong>即时编译器编译本地代码需要占用程序运行时间</strong>，通常要编译出优化程度越高的代码，所花费的时间便会越长； 而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。 <strong>为了在程序启动响应速度与运行效率之间达到最佳平衡：</strong></p><p>HotSpot虚拟机在编译子系统中加入了分层编译的功能，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包 括：</p><ul><li>第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li><li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启 性能监控功能。</li><li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li><li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启 用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/22/e2d911a20383f8cbab46d914f53ed80a.png" style="zoom:50%;"><h3 id="编译对象与触发条件" tabindex="-1"><a class="header-anchor" href="#编译对象与触发条件"><span>编译对象与触发条件</span></a></h3><p>会被即时编译器编译的目标是<code>热点代码</code>，这里所指的热点代码主要有两类：</p><ul><li>被<strong><em>多次</em>调用的方法。</strong></li><li>被<strong><em>多次</em>执行的循环体。</strong></li></ul><p><strong>对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。</strong></p><p>这种编译方式因为 编译发生在方法执行的过程中，因此被很形象地称为<code>栈上替换</code>（On Stack Replacement，OSR），即方法的栈帧还在栈上，方法就被替换了。</p><h4 id="多少次才算-多次-呢" tabindex="-1"><a class="header-anchor" href="#多少次才算-多次-呢"><span>多少次才算“多次”呢？</span></a></h4><p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”（Hot Spot Code Detection），判定方式：</p><ol><li><p><strong>基于采样的热点探测（Sample Based Hot Spot Code Detection）</strong></p><p>会周期性地检查各个线程的调用栈顶，如果发现<strong>某个方法经常出现在栈顶，那这个方法就是<code>热点方法</code>。</strong></p><p>缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测</p></li><li><p><strong>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</strong></p><p>为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果<strong>执行次数超过一定的阈值就认为它是<code>热点方法</code></strong>。</p><p>缺点：实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能 直接获取到方法的调用关系</p></li></ol><blockquote><p>J9用过第一种采样热点探测，而在HotSpot 虚拟机中使用的是第二种基于计数器的热点探测方法，</p></blockquote><h4 id="hotspot-中每个方法的-2-个计数器" tabindex="-1"><a class="header-anchor" href="#hotspot-中每个方法的-2-个计数器"><span>HotSpot 中每个方法的 2 个计数器</span></a></h4><ul><li><strong>方法调用计数器</strong><ul><li>统计方法被调用的次数，处理多次调用的方法的。</li><li>默认统计的不是方法调用的绝对次数，而是方法在一段时间内被调用的次数，如果超过这个时间限制还没有达到判为热点代码的阈值，则该方法的调用计数器值减半。 <ul><li>关闭热度衰减：<code>-XX: -UseCounterDecay</code>（此时方法计数器统计的是方法被调用的绝对次数）；</li><li>设置半衰期时间：<code>-XX: CounterHalfLifeTime</code>（单位是秒）；</li><li>热度衰减过程是在 GC 时顺便进行。</li><li>默认阈值在客户端模式下是1500次，在服务端模式下是10000次，</li></ul></li></ul></li><li><strong>回边计数器</strong><ul><li>统计一个方法中 “回边” 的次数，处理多次执行的循环体的。 <ul><li>回边：在字节码中遇到控制流向后跳转的指令（不是所有循环体都是回边，空循环体是自己跳向自己，没有向后跳，不算回边）。</li></ul></li><li>调整回边计数器阈值：<code>-XX: OnStackReplacePercentage</code>（OSR比率） <ul><li>Client 模式：<code>回边计数器的阈值 = 方法调用计数器阈值 * OSR比率 / 100</code>；</li><li>Server 模式：<code>回边计数器的阈值 = 方法调用计数器阈值 * ( OSR比率 - 解释器监控比率 ) / 100</code>；</li></ul></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/22/5cf6496226e33b90c9058391c75234d0.png" style="zoom:50%;"><h3 id="编译过程" tabindex="-1"><a class="header-anchor" href="#编译过程"><span>编译过程</span></a></h3><p>虚拟机在代码编译未完成时会按照解释方式继续执行，<strong>编译动作在后台的编译线程执行。</strong></p><p>禁止后台编译：<code>-XX: -BackgroundCompilation</code>，打开后这个开关参数后，交编译请求的线程会等待编译完成，然后执行编译器输出的本地代码。</p><p>在后台编译过程中，客户端编译器与服务端编译器是有区别的。</p><h4 id="客户端编译器" tabindex="-1"><a class="header-anchor" href="#客户端编译器"><span>客户端编译器</span></a></h4><p>是一个相对简单快速的三段式编译器，主要的<strong>关注点在于局部性的优化</strong>，而放弃了许多耗时较长的全局优化手段。</p><ol><li><p>第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）。HIR使用静态单分配 （Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，<strong>如方法内联、 常量传播等优化将会在字节码被构造成HIR之前完成。</strong></p></li><li><p>第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</p></li><li><p>最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。客户端编译器大致的执行过程如图</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/22/545057793d7a0d911250ca68a4bd6814.png" style="zoom:50%;"></li></ol><h4 id="服务端编译器" tabindex="-1"><a class="header-anchor" href="#服务端编译器"><span>服务端编译器</span></a></h4><p>是专门面向服务端的典型应用场景，执行大部分经典的优化动作，如：无用代码消除（Dead Code Elimination）、循环展开 （Loop Unrolling）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、常量传播（Constant Propagation）、基本块重排序（Basic Block Reordering）等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除（Range Check Elimination）、空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器优化的，有一些是代码运行过程中自动优化了）等。</p><p>另外，还可能根据解释器或客户端编译器提供的 性能监控信息，进行一些不稳定的预测性激进优化，如守护内联（Guarded Inlining）、分支频率预测 （Branch Frequency Prediction）等</p><p>服务端编译采用的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构（如 RISC）上的大寄存器集合。</p><h2 id="_2-2提前编译器" tabindex="-1"><a class="header-anchor" href="#_2-2提前编译器"><span>2.2提前编译器</span></a></h2><p>现在提前编译产品和对其的研究有着两条明显的分支：</p><ol><li><p>与传统C、C++编译器类似的，在<strong>程序运行之前把程序代码编译成机器码的静态翻译工作</strong></p></li><li><p>把原本<strong>即时编译器在运行时要做的编译工作提前做好并保存下来</strong>，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用。(本质是给即时编译器做缓存加速，去改善Java程序的启动时间)</p><blockquote><p>在目前的Java技术体系里，这种提前编译已经完全被主流的商用JDK支持</p><p>困难：这种提前编译方式不仅要和目标机器相关，甚至还必须与HotSpot虚拟机的运行时参数绑定（如生成内存屏障代码）才能正确工作，要做提前编译的话，自然也要把这些配合的工作平移过去。</p></blockquote></li></ol><h2 id="_2-3即时编译器的优势" tabindex="-1"><a class="header-anchor" href="#_2-3即时编译器的优势"><span>2.3即时编译器的优势</span></a></h2><p>提前编译的代码输出质量，一定会比即时编译更高吗？</p><p>以下为即时编译器相较于提前编译器的优势：</p><ol><li><p><strong>性能分析制导优化（Profile-Guided Optimization，PGO）</strong></p><p><strong>抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等</strong>，这些数据一般在静态分析时是无法得到的，或者不可能存在确定且唯一的解， 最多只能依照一些启发性的条件去进行猜测。但**在动态运行时却能看出它们具有非常明显的偏好性。**就可以把热的代码集中放到 一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它。</p></li><li><p><strong>激进预测性优化（Aggressive Speculative Optimization）</strong></p><p>静态优化无论如何都必须保证优化后所有的程序外部可见影响（不仅仅是执行结果） 与优化前是等效的</p><p>然而，即时编译的策略就可以不必这样保守，<strong>可以大胆地按照高概率的假设进行优化</strong>，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。</p><blockquote><p>如果Java虚拟机真的遇到虚方法就去查虚表而不做内 联的话，Java技术可能就已经因性能问题而被淘汰很多年了。</p><p>实际上虚拟机会通过类继承关系分析等 一系列激进的猜测去做去虚拟化（Devitalization），以保证绝大部分有内联价值的虚方法都可以顺利内联。</p></blockquote></li><li><p><strong>链接时优化（Link-Time Optimization，LTO）</strong></p><p>如C、C++的程序要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。 这是因为主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码。</p><p>然而，<strong>Java语言天生就是动态链接的</strong>，一个个 Class文件在运行期被加载到虚拟机内存当中。</p></li></ol><h1 id="三、编译器优化技术" tabindex="-1"><a class="header-anchor" href="#三、编译器优化技术"><span>三、编译器优化技术</span></a></h1><table><thead><tr><th>类型</th><th>优化技术</th></tr></thead><tbody><tr><td><strong>编译器策略 (Compiler Tactics)</strong></td><td></td></tr><tr><td></td><td>延迟编译 (Delayed Compilation)</td></tr><tr><td></td><td>分层编译 (Tiered Compilation)</td></tr><tr><td></td><td>栈上替换 (On-Stack Replacement)</td></tr><tr><td></td><td>延迟优化 (Delayed Reoptimization)</td></tr><tr><td></td><td>静态单赋值表示 (Static Single Assignment Representation)</td></tr><tr><td><strong>基于性能监控的优化技术 (Profile-Based Techniques)</strong></td><td></td></tr><tr><td></td><td>乐观空值断言 (Optimistic Nullness Assertions)</td></tr><tr><td></td><td>乐观类型断言 (Optimistic Type Assertions)</td></tr><tr><td></td><td>乐观类型增强 (Optimistic Type Strengthening)</td></tr><tr><td></td><td>乐观数组长度增强 (Optimistic Array Length Strengthening)</td></tr><tr><td></td><td>裁剪未被选择的分支 (Untaken Branch Pruning)</td></tr><tr><td></td><td>乐观的多态内联 (Optimistic N-morphic Inlining)</td></tr><tr><td></td><td>分支频率预测 (Branch Frequency Prediction)</td></tr><tr><td></td><td>调用频率预测 (Call Frequency Prediction)</td></tr><tr><td><strong>基于证据的优化技术 (Proof-Based Techniques)</strong></td><td></td></tr><tr><td></td><td>精确类型推断 (Exact Type Inference)</td></tr><tr><td></td><td>内存值推断 (Memory Value Inference)</td></tr><tr><td></td><td>内存值跟踪 (Memory Value Tracking)</td></tr><tr><td></td><td>常量折叠 (Constant Folding)</td></tr><tr><td></td><td>重组 (Reassociation)</td></tr><tr><td></td><td>操作符退化 (Operator Strength Reduction)</td></tr><tr><td></td><td>空值检查消除 (Null Check Elimination)</td></tr><tr><td></td><td>类型检测退化 (Type Test Strength Reduction)</td></tr><tr><td></td><td>类型检测消除 (Type Test Elimination)</td></tr><tr><td></td><td>代数简化 (Algebraic Simplification)</td></tr><tr><td></td><td>公共子表达式消除 (Common Subexpression Elimination)</td></tr><tr><td><strong>数据流敏感重写 (Flow-Sensitive Rewrites)</strong></td><td></td></tr><tr><td></td><td>条件常量传播 (Conditional Constant Propagation)</td></tr><tr><td></td><td>基于流承载的类型缩减转换 (Flow-Carried Type Narrowing)</td></tr><tr><td></td><td>无用代码消除 (Dead Code Elimination)</td></tr><tr><td><strong>语言相关的优化技术 (Language-Specific Techniques)</strong></td><td></td></tr><tr><td></td><td>类型继承关系分析 (Class Hierarchy Analysis)</td></tr><tr><td></td><td>去虚拟化 (Devirtualization)</td></tr><tr><td></td><td>符号常量传播 (Symbolic Constant Propagation)</td></tr><tr><td></td><td>自动装箱消除 (Autobox Elimination)</td></tr><tr><td></td><td>逃逸分析 (Escape Analysis)</td></tr><tr><td></td><td>锁消除 (Lock Elision)</td></tr><tr><td></td><td>锁膨胀 (Lock Coarsening)</td></tr><tr><td></td><td>消除反射 (De-reflection)</td></tr><tr><td><strong>内存及代码位置变换 (Memory and Placement Transformation)</strong></td><td></td></tr><tr><td></td><td>表达式提升 (Expression Hoisting)</td></tr><tr><td></td><td>表达式下沉 (Expression Sinking)</td></tr><tr><td></td><td>冗余存储消除 (Redundant Store Elimination)</td></tr><tr><td></td><td>相邻存储合并 (Adjacent Store Fusion)</td></tr><tr><td></td><td>交汇点分离 (Merge-Point Splitting)</td></tr><tr><td><strong>循环变换 (Loop Transformations)</strong></td><td></td></tr><tr><td></td><td>循环展开 (Loop Unrolling)</td></tr><tr><td></td><td>循环剥离 (Loop Peeling)</td></tr><tr><td></td><td>安全点消除 (Safepoint Elimination)</td></tr><tr><td></td><td>迭代范围分离 (Iteration Range Splitting)</td></tr><tr><td></td><td>范围检查消除 (Range Check Elimination)</td></tr><tr><td></td><td>循环向量化 (Loop Vectorization)</td></tr><tr><td><strong>全局代码调整 (Global Code Shaping)</strong></td><td></td></tr><tr><td></td><td>内联 (Inlining)</td></tr><tr><td></td><td>全局代码外提 (Global Code Motion)</td></tr><tr><td></td><td>基于热度的代码布局 (Heat-Based Code Layout)</td></tr><tr><td></td><td>Switch调整 (Switch Balancing)</td></tr><tr><td><strong>控制流图变换 (Control Flow Graph Transformation)</strong></td><td></td></tr><tr><td></td><td>本地代码编排 (Local Code Scheduling)</td></tr><tr><td></td><td>本地代码封包 (Local Code Bundling)</td></tr><tr><td></td><td>延迟槽填充 (Delay Slot Filling)</td></tr><tr><td></td><td>着色图寄存器分配 (Graph-Coloring Register Allocation)</td></tr><tr><td></td><td>线性扫描寄存器分配 (Linear Scan Register Allocation)</td></tr><tr><td></td><td>复写聚合 (Copy Coalescing)</td></tr><tr><td></td><td>常量分裂 (Constant Splitting)</td></tr><tr><td></td><td>复写移除 (Copy Removal)</td></tr><tr><td></td><td>地址模式匹配 (Address Mode Matching)</td></tr><tr><td></td><td>指令窥空优化 (Instruction Peepholing)</td></tr><tr><td></td><td>基于确定有限状态机的代码生成 (DFA-Based Code Generator)</td></tr></tbody></table><h2 id="_3-1一个优化的例子" tabindex="-1"><a class="header-anchor" href="#_3-1一个优化的例子"><span>3.1一个优化的例子</span></a></h2><p><strong>原始代码：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    z <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第一步优化：</strong> 方法内联（一般放在优化序列最前端，因为对其他优化有帮助）</p><p><strong>目的：</strong></p><ul><li>去除方法调用的成本（如建立栈帧等）</li><li>为其他优化建立良好的基础</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    z <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第二步优化：</strong> 公共子表达式消除</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...  // 因为这部分并没有改变 b.value 的值</span>
                       <span class="token comment">// 如果把 b.value 看成一个表达式，就是公共表达式消除</span>
    z <span class="token operator">=</span> y<span class="token punctuation">;</span>             <span class="token comment">// 把这一步的 b.value 替换成 y</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第三步优化：</strong> 复写传播</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    y <span class="token operator">=</span> y<span class="token punctuation">;</span>             <span class="token comment">// z 变量与以相同，完全没有必要使用一个新的额外变量</span>
                       <span class="token comment">// 所以将 z 替换为 y</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第四步优化：</strong> 无用代码消除</p><blockquote><p><strong>无用代码：</strong></p><ul><li>永远不会执行的代码</li><li>完全没有意义的代码</li></ul></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    <span class="token comment">// y = y; 这句没有意义的，去除</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-2方法内联" tabindex="-1"><a class="header-anchor" href="#_3-2方法内联"><span>3.2方法内联</span></a></h2><p>它是<strong>编译器最重要的优化手段</strong>，甚至都可以不加 上“之一”。</p><p>除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础</p><p>目的是：去除方法调用的成本（如建立栈帧等），并为其他优化建立良好的基础，所以一般将方法内联放在优化序列最前端，因为它对其他优化有帮助。</p><blockquote><p>为了解决虚方法的内联问题：引入<strong>类型继承关系分析（Class Hierarchy Analysis，CHA）</strong></p><p>用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类、子类是否为抽象类等。</p></blockquote><ul><li><strong>对于非虚方法：</strong><ul><li>直接进行内联，其调用方法的版本在编译时已经确定，是根据变量的静态类型决定的。</li></ul></li><li><strong>对于虚方法：</strong> （激进优化，要预留“逃生门”） <ul><li>向 CHA 查询此方法在当前程序下是否有多个目标可选择； <ul><li>只有一个目标版本： <ul><li>先对这唯一的目标进行内联；</li><li>如果之后的执行中，虚拟机没有加载到会令这个方法接收者的继承关系发生改变的新类，则该内联代码可以一直使用；</li><li>如果加载到导致继承关系发生变化的新类，就抛弃已编译的代码，退回到解释状态进行执行，或者重新进行编译。</li></ul></li><li>有多个目标版本： <ul><li>使用内联缓存，未发生方法调用前，内联缓存为空；</li><li>第一次调用发生后，记录调用方法的对象的版本信息；</li><li>之后的每次调用都要先与内联缓存中的对象版本信息进行比较； <ul><li>版本信息一样，继续使用内联代码，是一种<code>单态内联缓存</code>（Monomorphic Inline Cache）</li><li>版本信息不一样，说明程序使用了虚方法的多态特性，退化成<code>超多态内联缓存</code>（Megamorphic Inline Cache），查找虚方法进行方法分派。</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="_3-3逃逸分析【最前沿】" tabindex="-1"><a class="header-anchor" href="#_3-3逃逸分析【最前沿】"><span>3.3逃逸分析【最前沿】</span></a></h2><h4 id="基本行为" tabindex="-1"><a class="header-anchor" href="#基本行为"><span>基本行为</span></a></h4><p>分析对象的作用域，看它有没有能在当前作用域之外使用：</p><ul><li>方法逃逸：对象在方法中定义之后，能被外部方法引用，如作为参数传递到了其他方法中。</li><li>线程逃逸：赋值给 static 变量，或可以在其他线程中访问的实例变量。</li></ul><h4 id="对于不会逃逸到方法或线程外的对象能进行优化" tabindex="-1"><a class="header-anchor" href="#对于不会逃逸到方法或线程外的对象能进行优化"><span>对于不会逃逸到方法或线程外的对象能进行优化</span></a></h4><ul><li><strong>栈上分配：</strong> 对于不会逃逸到方法外的对象，可以在栈上分配内存，这样这个对象所占用的空间可以随栈帧出栈而销毁，减小 GC 的压力。</li><li><strong>标量替换（重要）：</strong><ul><li>标量：基本数据类型和 reference。</li><li>不创建对象，而是将对象拆分成一个一个标量，然后直接在栈上分配，是栈上分配的一种实现方式。</li><li>HotSpot 使用的是标量替换而不是栈上分配，因为实现栈上分配需要更改大量假设了 “对象只能在堆中分配” 的代码。</li></ul></li><li><strong>同步消除</strong><ul><li>如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，对这个变量实施的同步措施也就可以安全地消除掉。</li></ul></li></ul><h4 id="虚拟机参数" tabindex="-1"><a class="header-anchor" href="#虚拟机参数"><span>虚拟机参数</span></a></h4><ul><li>开启逃逸分析：<code>-XX: +DoEscapeAnalysis</code></li><li>开启标量替换：<code>-XX: +EliminateAnalysis</code></li><li>开启锁消除：<code>-XX: +EliminateLocks</code></li><li>查看分析结果：<code>-XX: PrintEscapeAnalysis</code></li><li>查看标量替换情况：<code>-XX: PrintEliminateAllocations</code></li></ul><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h3><p><strong>Point类的代码，这就是一个包含x和y坐标的POJO类型</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 完全未优化的代码</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>xx<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤1：构造函数内联</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token function">point_memory_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在堆中分配P对象的示意方法</span>
    p<span class="token punctuation">.</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span> <span class="token comment">// Point构造函数被内联后的样子</span>
    p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// Point::getX()被内联后的样子</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤2：标量替换</p><p>经过逃逸分析，发现在整个test()方法的范围内Point对象实例不会发生任何程度的逃逸， 这样可以对它进行标量替换优化，把其内部的x和y直接置换出来，分解为test()方法内的局部变量，从 而避免Point对象实例被实际创建</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> px <span class="token operator">=</span> xx<span class="token punctuation">;</span>
    <span class="token keyword">int</span> py <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤3：无效代码消除</p><p>通过数据流分析，发现py的值其实对方法不会造成任何影响，那就可以放心地去做无效代码消除得到最终优化结果，</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div><!--[--><!----><!--]--><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/src/book/深入理解Java虚拟机/JVM学习-程序编译与优化.md" rel="noopener noreferrer" target="_blank" aria-label="在 GitHub 上编辑此页" class="nav-link vp-meta-label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="vp-meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><!----><a class="route-link nav-link next" href="/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" aria-label="类加载机制"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">类加载机制<span class="font-icon icon fa-fw fa-sm fas fa-lightbulb" style=""></span></div></a></nav><div id="vp-comment" class="giscus-wrapper input-top" style="display:block;"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" preserveAspectRatio="xMidYMid" viewBox="0 0 100 100"><circle cx="28" cy="75" r="11" fill="currentColor"><animate attributeName="fill-opacity" begin="0s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></circle><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 47a28 28 0 0 1 28 28"><animate attributeName="stroke-opacity" begin="0.1s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 25a50 50 0 0 1 50 50"><animate attributeName="stroke-opacity" begin="0.2s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path></svg></div><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2024 Mr.Hope </div></footer></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-D1py-eEI.js" defer></script>
  </body>
</html>
