import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as p,o as l,c as o,b as n,e as s,f as c,d as a}from"./app-D1py-eEI.js";const i={},u=a(`<h1 id="一、执行引擎" tabindex="-1"><a class="header-anchor" href="#一、执行引擎"><span>一、执行引擎</span></a></h1><p>在Java虚拟机的概念模型中，执行引擎是负责执行虚拟机中的字节码指令集的组件。执行引擎的工作涉及到方法的调用和字节码的执行。在不同的虚拟机实现中，执行引擎的具体实现方式可能会有所不同，但从外观上看，其输入和输出是一致的。执行引擎接收字节码的二进制流作为输入，经过处理执行字节码指令，然后输出执行结果。</p><p>执行引擎的工作方式通常包括解释执行和编译执行两种选择，有些虚拟机甚至同时支持两者。具体来说：</p><ol><li><strong>解释执行：</strong> 在解释执行模式下，执行引擎会逐条解释字节码指令，并将其转换为对应的本地机器指令执行。这种方式的优点是简单直观，不需要等待编译过程，可以快速执行。缺点是解释执行效率相对较低，因为每次执行都需要解释一次。</li><li><strong>编译执行：</strong> 在编译执行模式下，执行引擎会通过即时编译器将字节码直接编译成本地机器代码，然后执行编译后的本地代码。这种方式的优点是执行效率高，因为避免了重复解释的开销。缺点是需要在程序运行之前进行编译，可能会增加启动时间。</li></ol><p>概念模型提供了虚拟机执行引擎的统一外观，使得不同的虚拟机实现可以在一致的概念框架下工作。这种设计使得Java程序在不同的虚拟机上具有较好的可移植性。</p><h1 id="二、运行时栈帧" tabindex="-1"><a class="header-anchor" href="#二、运行时栈帧"><span>二、运行时栈帧</span></a></h1><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/image-20231123143211613.png" alt="image-20231123143211613" style="zoom:50%;"><p>Java虚拟机以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持虚拟机进行方法 调用和方法执行背后的数据结构</p><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 在<strong>编译Java程序源码的时</strong>候，栈帧中需要<strong>多大的局部变量表，需要多深的操作数栈就已经被分析计算</strong>出来，并且写入到方法表的Code属性之中</p><blockquote><p>一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p></blockquote><p>在Java程序中，一个线程中的方法调用链可能会很长。然而，从执行引擎的角度来看，在同一时刻、同一条线程里，只有调用堆栈的栈顶方法处于执行状态。这个<strong>正在执行的方法所对应的栈帧被称为当前栈帧</strong>（Current Stack Frame），而**与这个栈帧相关联的方法被称为当前方法（**Current Method）。模型如下图：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/image-20231123144255299.png" alt="image-20231123144255299" style="zoom:50%;"><p>执行引擎在活动线程中只关注当前栈帧，只有当前栈帧中的方法才是正在执行的。这种设计简化了执行引擎的实现，使其能够专注于当前正在执行的方法，而不必考虑整个调用链。在执行引擎执行字节码指令时，它只关注当前栈帧，即当前方法的栈帧，所有的操作都是针对这个栈帧进行的。</p><blockquote><p>这种方式也符合Java程序员的直觉，因为在编写Java程序时，通常是从一个方法调用到另一个方法，形成调用链。而在执行过程中，只有最顶层的方法（当前方法）才是直接在执行，其余的方法调用都处于等待状态。这种调用链的执行方式保证了在单线程执行中，方法调用的顺序和预期一致。</p></blockquote><h2 id="_2-1局部变量表" tabindex="-1"><a class="header-anchor" href="#_2-1局部变量表"><span>2.1局部变量表</span></a></h2><ul><li>存放方法参数和方法内部定义的局部变量； <ul><li>Java 程序编译为 class 文件时，就确定了每个方法需要分配的局部变量表的最大容量。</li></ul></li><li>最小单位：Slot； <ul><li>一个 Slot 中可以存放：boolean，byte，char，short，int，float，reference(对象的实例引用)，returnAddress (少见，指向字节码指令的地址，之前用来异常时跳转，后来被异常表取代)；</li><li>虚拟机可通过局部变量表中的 reference 做到： <ul><li>查找 Java 堆中的实例对象的起始地址；</li><li>查找方法区中的 Class 对象。</li></ul></li></ul></li></ul><h3 id="局部变量表的空间分配" tabindex="-1"><a class="header-anchor" href="#局部变量表的空间分配"><span>局部变量表的空间分配</span></a></h3><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/image-20231123153302843.png" alt="image-20231123153302843" style="zoom:33%;"><h3 id="slot-的复用" tabindex="-1"><a class="header-anchor" href="#slot-的复用"><span>Slot 的复用</span></a></h3><p><strong>定义：</strong> 如果当前位置已经超过某个变量的作用域时，例如出了定义这个变量的代码块，这个变量对应的 Slot 就可以给其他变量使用了。但同时也说明，只要其他变量没有使用这部分 Slot 区域，这个变量就还保存在那里，这会对 GC 操作产生影响。</p><h4 id="对-gc-操作的影响" tabindex="-1"><a class="header-anchor" href="#对-gc-操作的影响"><span><strong>对 GC 操作的影响：</strong></span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
    	<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-verbose:gc</code> 输出：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>System.gc<span class="token punctuation">(</span><span class="token punctuation">))</span>  68813K-<span class="token operator">&gt;</span>66304K<span class="token punctuation">(</span>123904K<span class="token punctuation">)</span>, <span class="token number">0.0034797</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>System.gc<span class="token punctuation">(</span><span class="token punctuation">))</span>  66304K-<span class="token operator">&gt;</span>66204K<span class="token punctuation">(</span>123904K<span class="token punctuation">)</span>, <span class="token number">0.0086225</span> secs<span class="token punctuation">]</span>  // 没有被回收
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>进行如下修改：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
    	<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> placeholder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">64</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 新加一个赋值操作</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-verbose:gc</code> 输出：</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>GC <span class="token punctuation">(</span>System.gc<span class="token punctuation">(</span><span class="token punctuation">))</span>  68813K-<span class="token operator">&gt;</span>66320K<span class="token punctuation">(</span>123904K<span class="token punctuation">)</span>, <span class="token number">0.0017394</span> secs<span class="token punctuation">]</span>
<span class="token punctuation">[</span>Full GC <span class="token punctuation">(</span>System.gc<span class="token punctuation">(</span><span class="token punctuation">))</span>  66320K-<span class="token operator">&gt;</span>668K<span class="token punctuation">(</span>123904K<span class="token punctuation">)</span>, <span class="token number">0.0084337</span> secs<span class="token punctuation">]</span>  // 被回收了
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第二次修改后，placeholder 能被回收的原因？</strong></p><ul><li>placeholder 能否被回收的关键：局部变量表中的 Slot 是否还存在关于 placeholder 的引用；</li><li>出了 placeholder 所在的代码块后，还没有进行其他操作，所以 placeholder 所在的 Slot 还没有被其他变量复用，也就是说，局部变量表的 Slot 中依然存在着 placeholder 的引用；</li><li>第二次修改后，int a 占用了原来 placeholder 所在的 Slot，所以可以被 GC 掉了。</li></ul><h2 id="_2-2操作数栈" tabindex="-1"><a class="header-anchor" href="#_2-2操作数栈"><span>2.2操作数栈</span></a></h2><ul><li>元素可以是任意 Java 类型，32 位数据占 1 个栈容量，64 位数据占 2 个栈容量；</li><li>Java 虚拟机的解释执行称为：基于栈的执行引擎，其中 “栈” 指的就是操作数栈；</li></ul><p>在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。</p><blockquote><p>但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。 **让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，**这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/image-20231123154126268.png" alt="image-20231123154126268" style="zoom:50%;"></blockquote><h2 id="_2-3动态连接" tabindex="-1"><a class="header-anchor" href="#_2-3动态连接"><span>2.3动态连接</span></a></h2>`,35),d={href:"https://gaoyubo.cn/blogs/6997cf1f.html#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F",target:"_blank",rel:"noopener noreferrer"},k=n("li",null,"为了支持方法调用过程中的动态连接，什么是动态连接会在下一篇文章进行讲解，先知道有这么个东西就行。",-1),r=a(`<img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/image-20231123155716690.png" alt="image-20231123155716690" style="zoom:50%;"><h2 id="_2-4方法返回地址" tabindex="-1"><a class="header-anchor" href="#_2-4方法返回地址"><span>2.4方法返回地址</span></a></h2><ul><li><p><strong>两种退出方法的方式：</strong></p><ul><li>遇到 return；</li><li>遇到异常。</li></ul><blockquote><p>无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用时的位置，即有一个返回到最初方法的地址。</p><p>正常退出：<strong>主调方法的PC计数器的值就可以作为返回地址</strong>，栈帧中很可能会保存这个计数器值。 异常退出：返回地址是要通过<strong>异常处理器表来确定</strong>的，栈帧中就一般不会保存这部分信息。</p></blockquote></li><li><p><strong>退出方法时可能执行的操作：</strong></p><ul><li>恢复上层方法的局部变量表和操作数栈；</li><li>把返回值压入调用者栈帧的操作数栈；</li><li>调整 PC 计数器指向方法调用后面的指令。</li></ul></li></ul><h2 id="_2-5附加信息" tabindex="-1"><a class="header-anchor" href="#_2-5附加信息"><span>2.5附加信息</span></a></h2><p>Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试、 性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现，这里不再详述。</p><blockquote><p>在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。</p></blockquote><h1 id="三、方法调用" tabindex="-1"><a class="header-anchor" href="#三、方法调用"><span>三、方法调用</span></a></h1><p>Java 的方法的执行分为两个部分：</p><ul><li>方法调用：确定被调用的方法是哪一个；</li><li>基于栈的解释执行：真正的执行方法的字节码。</li></ul><p>在本节中我们将对方法调用进行详细的讲解，我们知道，一切方法的调用在 Class 文件中存储的都是常量池中的符号引用，而不是方法实际运行时的入口地址（直接引用），直到类加载的时候，甚至是实际运行的时候才回去会去确定要被运行的方法的直接引用，而确定要被运行的方法的直接引用的过程就叫做方法调用。</p><h2 id="_3-1字节码指令" tabindex="-1"><a class="header-anchor" href="#_3-1字节码指令"><span>3.1字节码指令</span></a></h2><p>Java 虚拟机提供了 5 个职责不同的方法调用字节码指令：</p><ul><li><code>invokestatic</code>：调用静态方法；</li><li><code>invokespecial</code>：调用构造器方法、私有方法、父类方法；</li><li><code>invokevirtual</code>：调用所有虚方法，除了静态方法、构造器方法、私有方法、父类方法、final 方法的其他方法叫虚方法；</li><li><code>invokeinterface</code>：调用接口方法，会在运行时确定一个该接口的实现对象；</li><li><code>invokedynamic</code>：在运行时动态解析出调用点限定符引用的方法，再执行该方法。</li></ul><p>除了 <code>invokedynamic</code>，其他 4 种方法的第一个参数都是被调用的方法的符号引用，是在编译时确定的，所以它们缺乏动态类型语言支持，因为动态类型语言只有在运行期才能确定接收者的类型，即变量的类型检查的主体过程在运行期，而非编译期。</p><blockquote><p>final 方法虽然是通过 <code>invokevirtual</code> 调用的，但是其无法被覆盖，没有其他版本，无需对接收者进行多态选择，或者说多态选择的结果是唯一的，所以属于非虚方法。</p></blockquote><h2 id="_3-2解析调用" tabindex="-1"><a class="header-anchor" href="#_3-2解析调用"><span>3.2解析调用</span></a></h2><p>解析调用，正如其名，就是 <strong>在类加载的解析阶段，就确定了方法的调用版本</strong> 。我们知道类加载的解析阶段会将一部分符号引用转化为直接引用，这一过程就叫做解析调用。因为是在程序真正运行前就确定了要调用哪一个方法，所以 <strong>解析调用能成立的前提就是：方法在程序真正运行前就有一个明确的调用版本了，并且这个调用版本不会在运行期发生改变。</strong></p><p>符合这两个要求的只有以下两类方法：</p><ul><li>通过 <code>invokestatic</code> 调用的方法：静态方法；</li><li>通过 <code>invokespecial</code> 调用的方法：私有方法、构造器方法、父类方法；</li></ul><p>这两类方法根本不可能通过继承或者别的方式重写出来其他版本，也就是说，在运行前就可以确定调用版本了，十分适合在类加载阶段就解析好。它们会在类加载的解析阶被解析为直接引用，即确定调用版本。</p><h2 id="_3-3分派解析" tabindex="-1"><a class="header-anchor" href="#_3-3分派解析"><span>3.3分派解析</span></a></h2><p>Java 所具备的面向对象的 3 个基本特征：封装，继承，多态。</p><p>其中多态最基本的体现就是重载和重写了，重载和重写的一个重要特征就是方法名相同，其他各种不同：</p><ul><li>重载：发生在同一个类中，入参必须不同，返回类型、访问修饰符、抛出的异常都可以不同；</li><li>重写：发生在子父类中，入参和返回类型必须相同，访问修饰符大于等于被重写的方法，不能抛出新的异常。</li></ul><p>相同的方法名实际上给虚拟机的调用带来了困惑，因为虚拟机需要判断，它到底应该调用哪个方法，而这个过程会在分派调用中体现出来。其中：</p><ul><li>方法重载 —— 静态分派</li><li>方法重写 —— 动态分派</li></ul><h3 id="静态分派-方法重载" tabindex="-1"><a class="header-anchor" href="#静态分派-方法重载"><span>静态分派（方法重载）</span></a></h3><p>在介绍静态分派前，我们先来介绍一下什么是变量的静态类型和实际类型。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StaticDispatch</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Human</span> guy<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello guy!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Man</span> man<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello man!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token class-name">Woman</span> woman<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello woman!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">StaticDispatch</span> sr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StaticDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>man<span class="token punctuation">)</span><span class="token punctuation">;</span>
        sr<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span>woman<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* 输出：
        Hello guy!
        Hello guy!
        因为是根据变量的静态类型，也就是左面的类型：Human 来判断调用哪个方法，
        所以调用的都是 public void sayHello(Human guy)
        */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中 <code>Human</code> 称为变量的静态类型，<code>Man</code> 称为变量的实际类型。</p><p>在重载时，编译器是通过方法参数的静态类型，而不是实际类型，来判断应该调用哪个方法的。</p><p>静态分派就是通过方法的参数（类型 &amp; 个数 &amp; 顺序）这种静态的东西来判断到底调用哪个方法的过程。**</p><h4 id="重载方法匹配优先级" tabindex="-1"><a class="header-anchor" href="#重载方法匹配优先级"><span>重载方法匹配优先级</span></a></h4><p>例如一个字符 &#39;a&#39; 作为入参</p><ul><li>基本类型 <ul><li>char</li><li>int</li><li>long</li><li>float</li><li>double</li></ul></li><li>Character</li><li>Serializable（Character 实现的接口） <ul><li>同时出现两个优先级相同的接口，如 Serializable 和 Comparable，会提示类型模糊，拒绝编译。</li></ul></li><li>Object</li><li>char...（变长参数优先级最低）</li></ul><h3 id="动态分派-方法重写" tabindex="-1"><a class="header-anchor" href="#动态分派-方法重写"><span>动态分派（方法重写）</span></a></h3><p>动态分派就是在运行时，根据实际类型确定方法执行版本的分派过程。</p><h4 id="动态分派的过程" tabindex="-1"><a class="header-anchor" href="#动态分派的过程"><span>动态分派的过程</span></a></h4><p>我们先来看一个例子：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DynamicDispatch</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
  	  <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Man</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello man&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello woman&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Human</span> man <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Man</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Human</span> woman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        woman<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        man <span class="token operator">=</span> woman<span class="token punctuation">;</span>
        man<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* 输出
        Hello man
        Hello woman
        Hello woman
        */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字节码分析：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
        stack=2, locals=3, args_size=1
        0: new           #2      // class com/jvm/ch8/DynamicDispatch$Man
        3: dup
        4: invokespecial #3      // Method com/jvm/ch8/DynamicDispatch$Man.&quot;&lt;init&gt;&quot;:()V
        7: astore_1
        8: new           #4      // class com/jvm/ch8/DynamicDispatch$Woman
        11: dup
        12: invokespecial #5     // Method com/jvm/ch8/DynamicDispatch$Woman.&quot;&lt;init&gt;&quot;:()V
        15: astore_2
        16: aload_1		        // 把刚创建的对象的引用压到操作数栈顶，
        					   // 供之后执行sayHello时确定是执行哪个对象的sayHello
        17: invokevirtual #6    // 方法调用
        20: aload_2             // 把刚创建的对象的引用压到操作数栈顶，
                                // 供之后执行sayHello时确定是执行哪个对象的sayHello
        21: invokevirtual #6    // 方法调用
        24: aload_2
        25: astore_1
        26: aload_1
        27: invokevirtual #6    // Method com/jvm/ch8/DynamicDispatch$Human.sayHello:()V
        30: return
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过字节码分析可以看出，<code>invokevirtual</code> 指令的运行过程大致为：</p><ol><li>去操作数栈顶取出将要执行的方法的所有者，记作 C；</li><li>查找此方法：</li><li><ul><li>在 C 中查找此方法；</li><li>C中不存在则在 C 的各个父类中查找；</li><li>查找过程： <ul><li>查找与常量的描述符和简单名称都相同的方法；</li><li>进行访问权限验证，不通过抛出：IllegalAccessError 异常；</li><li>通过访问权限验证则返回直接引用；</li></ul></li></ul></li><li>没找到则抛出：AbstractMethodError 异常，即该方法没被实现。</li></ol><h4 id="动态分派的实现" tabindex="-1"><a class="header-anchor" href="#动态分派的实现"><span>动态分派的实现</span></a></h4><p>动态分派在虚拟机种执行的非常频繁，而且方法查找的过程要在类的方法元数据中搜索合适的目标，从性能上考虑，不太可能进行如此频繁的搜索，需要进行性能上的优化。</p><p><strong>常用优化手段：</strong> 在类的方法区中建立一个虚方法表。</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/image-20231130153247413.png" alt="image-20231130153247413" style="zoom:50%;"><ul><li>虚方法表中存放着各个方法的实际入口地址，如果某个方法没有被子类方法重写，那子类方法表中该方法的入口地址 = 父类方法表中该方法的入口地址；</li><li>使用这个方法表索引代替在元数据中查找；</li><li>该方法表会在类加载的连接阶段初始化好。</li></ul><p><strong>通俗的讲，动态分派就是通过方法的接收者这种动态的东西来判断到底调用哪个方法的过程。</strong></p><blockquote><p>静态分派看左面，动态分派看右面。</p></blockquote><h3 id="字段没有多态性" tabindex="-1"><a class="header-anchor" href="#字段没有多态性"><span>字段没有多态性</span></a></h3><p>多态性的根源是虚方法调用指令<code>invokevirtual</code>的执行逻辑。这种多态性仅适用于方法，对字段是无效的，因为字段不使用这条指令。<strong>在Java中，只有方法存在虚拟性，字段永远不可能是虚拟的。</strong></p><p>换句话说，字段不参与多态性。当一个类的方法访问某个字段时，该字段指的是该类能够看到的那个字段。当子类声明了与父类同名的字段时，尽管在子类的内存中两个字段都存在，但子类的字段会遮蔽父类的同名字段。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldHasNoPolymorphic</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        
        <span class="token keyword">public</span> <span class="token class-name">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I am Father, I have $&quot;</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Son</span> <span class="token keyword">extends</span> <span class="token class-name">Father</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">int</span> money <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
        
        <span class="token keyword">public</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            money <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
            <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showMeTheMoney</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I am Son, I have $&quot;</span> <span class="token operator">+</span> money<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Father</span> guy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;This guy has $&quot;</span> <span class="token operator">+</span> guy<span class="token punctuation">.</span>money<span class="token punctuation">)</span><span class="token punctuation">;</span>
       	<span class="token comment">/*
       	输出结果：
			I am Son, i have $0
			I am Son, i have $4
			This gay has $2
        */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解释： 输出两句都是“I am Son”，这是因为Son类在创建的时候，首先隐式调用了Father的构造函数，而Father构造函数中对showMeTheMoney()的调用是一次虚方法调用，实际执行的版本是Son::showMeTheMoney()方法，所以输出的是“I am Son”。</p><ul><li>此时但Son::showMeTheMoney()方法中访问的却是子类的money字段，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。</li><li>然后显示调用Son类的构造函数，此时money已经被初始化为4了，所以输出4。</li><li>main()的最后一句通过静态类型访问到了父类中的money，输出了2。</li></ul><h2 id="_3-4单分派与多分派" tabindex="-1"><a class="header-anchor" href="#_3-4单分派与多分派"><span>3.4单分派与多分派</span></a></h2><p>除了静态分派和动态分派这种分派分类方式，还有一种根据宗量分类的方式，可以将方法分派分为单分派和多分派。</p><blockquote><p>宗量：方法的接收者 &amp; 方法的参数。</p></blockquote><p>Java 语言的静态分派属于多分派，根据 <strong>方法接收者的静态类型</strong> 和 <strong>方法参数类型</strong> 两个宗量进行选择。</p><p>Java 语言的动态分派属于单分派，只根据 <strong>方法接收者的实际类型</strong> 一个宗量进行选择。</p><h2 id="_3-5总结" tabindex="-1"><a class="header-anchor" href="#_3-5总结"><span>3.5总结</span></a></h2><p>Java语言可以被分类为<strong>静态多分派、动态单分派</strong>的语言，这个结论适用于Java 12和Java 13这些版本。需要强调的是，这个结论并不是永久不变的，未来Java语言的发展可能会引入新的特性改变这个分类。</p><p>举例来说，C#在3.0版本及之前与Java类似，也是动态单分派语言。然而，C#在4.0版本引入了<code>dynamic</code>类型，使得动态多分派变得更加方便。</p><p>在Java中，虽然在JDK 10中引入了<code>var</code>关键字，但是请不要将其与C#中的<code>dynamic</code>类型混淆。实际上，Java的<code>var</code>与C#的<code>var</code>是相对应的特性，它们都是语法糖，用于在编译时根据右侧表达式的类型进行静态类型推断。</p><p>与C#的<code>dynamic</code>类型相对应的，是在JDK 9中引入的<code>jdk.dynalink</code>模块。通过使用<code>jdk.dynalink</code>，可以在Java表达式中使用动态类型。编译器（Javac）会将这些动态类型的操作转化为<code>invokedynamic</code>指令的调用点。</p><blockquote><ul><li>Java语言在静态类型分派上是多分派的，即根据方法参数的静态类型来决定调用哪个方法。</li><li>在动态类型分派上是单分派的，即根据接收者的动态类型来决定调用哪个方法。</li><li>需要注意的是，Java的<code>var</code>关键字与C#的<code>dynamic</code>类型是不同的概念，Java中与C#的<code>dynamic</code>类型类似的功能可以通过<code>jdk.dynalink</code>模块来实现。</li></ul></blockquote><h1 id="四、动态类型语言支持" tabindex="-1"><a class="header-anchor" href="#四、动态类型语言支持"><span>四、动态类型语言支持</span></a></h1><p><strong>什么是动态类型语言？</strong></p><p>就是类型检查的主体过程在运行期，而非编译期的编程语言。</p><p><strong>动/静态类型语言各自的优点？</strong></p><ul><li>动态类型语言：灵活性高，开发效率高。</li><li>静态类型语言：编译器提供了严谨的类型检查，类型相关的问题能在编码的时候就发现。</li></ul><p><strong>Java虚拟机层面提供的动态类型支持：</strong></p><ul><li><code>invokedynamic</code> 指令</li><li>java.lang.invoke 包</li></ul><h3 id="java-lang-invoke-包" tabindex="-1"><a class="header-anchor" href="#java-lang-invoke-包"><span>java.lang.invoke 包</span></a></h3><p><strong>目的：</strong> 在之前的依靠符号引用确定调用的目标方法的方式之外，提供了 MethodHandle 这种动态确定目标方法的调用机制。</p><h4 id="methodhandle-的使用" tabindex="-1"><a class="header-anchor" href="#methodhandle-的使用"><span>MethodHandle 的使用</span></a></h4><ul><li><p>获得方法的参数描述，第一个参数是方法返回值的类型，之后的参数是方法的入参：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">MethodType</span> mt <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>获取一个普通方法的调用：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 需要的参数：
 * 1. 被调用方法所属类的类对象
 * 2. 方法名
 * 3. MethodType 对象 mt
 * 4. 调用该方法的对象
 */</span>
<span class="token class-name">MethodHandle</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>receiver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;方法名&quot;</span><span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>获取一个父类方法的调用：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 需要的参数：
 * 1. 被调用方法所属类的类对象
 * 2. 方法名
 * 3. MethodType 对象 mt
 * 4. 调用这个方法的类的类对象
 */</span>
<span class="token class-name">MethodHandle</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findSpecial</span><span class="token punctuation">(</span><span class="token class-name">GrandFather</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;方法名&quot;</span><span class="token punctuation">,</span> mt<span class="token punctuation">,</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>通过 <code>MethodHandle mh</code> 执行方法：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">/* 
invoke() 和 invokeExact() 的区别：
- invokeExact() 要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内
- invoke() 允许更加松散的调用方式
*/</span>
mh<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mh<span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><p>使用示例：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MethodHandleTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
        obj的静态类型是Object，是没有println方法的，所以尽管obj的实际类型都包含println方法，
        它还是不能调用println方法
         */</span>
        <span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">ClassA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        invoke()和invokeExact()的区别：
        - invokeExact()要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内
        - invoke()允许更加松散的调用方式
         */</span>
        <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">invokeExact</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">MethodHandle</span> <span class="token function">getPrintlnMH</span><span class="token punctuation">(</span><span class="token class-name">Object</span> receiver<span class="token punctuation">)</span> 
        	<span class="token keyword">throws</span> <span class="token class-name">NoSuchMethodException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">{</span>
        <span class="token comment">/* MethodType代表方法类型，第一个参数是方法返回值的类型，之后的参数是方法的入参 */</span>
        <span class="token class-name">MethodType</span> mt <span class="token operator">=</span> <span class="token class-name">MethodType</span><span class="token punctuation">.</span><span class="token function">methodType</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/*
        lookup()方法来自于MethodHandles.lookup，
        这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄
        */</span>
        <span class="token comment">/*
        因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，
        也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情
        */</span>
        <span class="token keyword">return</span> <span class="token class-name">MethodHandles</span><span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findVirtual</span><span class="token punctuation">(</span>receiver<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;println&quot;</span><span class="token punctuation">,</span> mt<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bindTo</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>MethodHandles.lookup 中 3 个方法对应的字节码指令：</strong></p><ul><li><code>findStatic()</code>：对应 invokestatic</li><li><code>findVirtual()</code>：对应 invokevirtual &amp; invokeinterface</li><li><code>findSpecial()</code>：对应 invokespecial</li></ul><h4 id="methodhandle-和-reflection-的区别" tabindex="-1"><a class="header-anchor" href="#methodhandle-和-reflection-的区别"><span>MethodHandle 和 Reflection 的区别</span></a></h4><ul><li><strong>本质区别：</strong> 它们都在模拟方法调用，但是 <ul><li>Reflection 模拟的是 Java 代码层次的调用；</li><li>MethodHandle 模拟的是字节码层次的调用。</li></ul></li><li><strong>包含信息的区别：</strong><ul><li>Reflection 的 Method 对象包含的信息多，包括：方法签名、方法描述符、方法的各种属性的Java端表达方式、方法执行权限等；</li><li>MethodHandle 对象包含的信息比较少，既包含与执行该方法相关的信息。</li></ul></li></ul><h3 id="invokedynamic-指令" tabindex="-1"><a class="header-anchor" href="#invokedynamic-指令"><span><code>invokedynamic</code> 指令</span></a></h3><p>Lambda 表达式就是通过 <code>invokedynamic</code> 指令实现的。</p><h1 id="五、基于栈的字节码解释执行引擎" tabindex="-1"><a class="header-anchor" href="#五、基于栈的字节码解释执行引擎"><span>五、基于栈的字节码解释执行引擎</span></a></h1><p>这个栈，就是栈帧中的操作数栈。</p><blockquote><p>与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令 集，如果说得更通俗一些就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄 存器进行工作。</p></blockquote><h2 id="解释执行" tabindex="-1"><a class="header-anchor" href="#解释执行"><span>解释执行</span></a></h2><p>先通过 javac 将代码编译成字节码，虚拟机再通过加载字节码文件，解释执行字节码文件生成机器码，解释执行的流程如下：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>词法分析 -&gt; 语法分析 -&gt; 形成抽象语法树 -&gt; 遍历语法树生成线性字节码指令流
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="指令集分类" tabindex="-1"><a class="header-anchor" href="#指令集分类"><span>指令集分类</span></a></h2><h3 id="基于栈的指令集" tabindex="-1"><a class="header-anchor" href="#基于栈的指令集"><span>基于栈的指令集</span></a></h3><ul><li><p><strong>优点：</strong></p><ul><li>可移植：寄存器由硬件直接提供，程序如果直接依赖这些硬件寄存器，会不可避免的受到硬件的约束；</li><li>代码更紧凑：字节码中每个字节对应一条指令，多地址指令集中还需要存放参数；</li><li>编译器实现更简单：不需要考虑空间分配问题，所需的空间都在栈上操作。</li></ul></li><li><p><strong>缺点：</strong> 执行速度稍慢</p><ul><li>完成相同的功能，需要更多的指令，因为出入栈本身就产生相当多的指令；</li><li>频繁的栈访问导致频繁的内存访问，对于处理器而言，内存是执行速度的瓶颈。</li></ul></li><li><p><strong>示例：</strong> 两数相加</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>iconst_1  // 把常量1入栈
iconst_1
iadd      // 把栈顶两元素出栈相加，结果入栈
istore_0  // 把栈顶值存入第0个Slot中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h3 id="基于寄存器的指令集" tabindex="-1"><a class="header-anchor" href="#基于寄存器的指令集"><span>基于寄存器的指令集</span></a></h3><p><strong>示例：</strong> 两数相加</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>mov  eax, 1
add  eax, 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="执行过程分析" tabindex="-1"><a class="header-anchor" href="#执行过程分析"><span>执行过程分析</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Architecture</span> <span class="token punctuation">{</span>
    <span class="token comment">/*
    calc函数的字节码分析：
    public int calc();
    descriptor: ()I
    flags: ACC_PUBLIC
    Code:
    stack=2, locals=4, args_size=1 // stack=2，说明需要深度为2的操作数栈
                                   // locals=4，说明需要4个Slot的局部变量表
    0: bipush 100                  // 将单字节的整型常数值push到操作数栈
    2: istore_1                    // 将操作数栈顶的整型值出栈并存放到第一个局部变量Slot中
    3: sipush 200
    6: istore_2
    7: sipush 300
    10: istore_3
    11: iload_1                    // 将局部变量表第一个Slot中的整型值复制到操作数栈顶
    12: iload_2
    13: iadd                       // 将操作数栈中头两个元素出栈并相加，将结果重新入栈
    14: iload_3
    15: imul                       // 将操作数栈中头两个元素出栈并相乘，将结果重新入栈
    16: ireturn                    // 返回指令，结束方法执行，将操作数栈顶的整型值返回给此方法的调用者
    */</span>
    
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">*</span> c<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Architecture</span> architecture <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Architecture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        architecture<span class="token punctuation">.</span><span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="六、实现-java-类的热替换" tabindex="-1"><a class="header-anchor" href="#六、实现-java-类的热替换"><span>六、实现 Java 类的热替换</span></a></h1><h2 id="什么是热替换及其实现原理" tabindex="-1"><a class="header-anchor" href="#什么是热替换及其实现原理"><span>什么是热替换及其实现原理</span></a></h2><ul><li>热替换是在不停止正在运行的系统的情况下进行类（对象）的升级替换；</li><li>这要求虚拟机中要存在同一个类的两个不同版本。可我们知道，我们是无法将同一个类加载两遍的，想要实现这点，我们需要让虚拟机认为这是两个不同的类，即用两个不同的类加载器去加载这个类不同版本的 class 文件；</li><li>因此，这个工作就不能由系统提供给我们的启动类加载器，扩展类加载器或者应用程序类加载器来完成，因为这三个类加载器在同一个虚拟机中只有一份，不仅如此，我们还要跳过这些类加载器；</li><li>想要跳过这些类加载器可不是只要不用这些类加载器就行了，还需要我们跳过双亲委派模型，否则类的加载还会被委派到这些个类加载器，如果恰好某个类之前是由这三个类加载器中的一个加载的，虚拟机就不会再次加载新版本的类了，就无法实现类的热替换了。</li></ul><h2 id="实现简单的-java-类热替换" tabindex="-1"><a class="header-anchor" href="#实现简单的-java-类热替换"><span>实现简单的 Java 类热替换</span></a></h2><h3 id="需求分析" tabindex="-1"><a class="header-anchor" href="#需求分析"><span>需求分析</span></a></h3><p>现有一 Foo 类，可以在控制台持续打印：Hello world! version one，我们将在该类运行时，将其 .class 文件替换为修改后的 Foo 类的 .class 文件，修改后的 Foo 会在控制台持续打印：Hello world! version two。也就是说，替换之后，控制台打印的内容发生变化，就说明类的热替换实现成功。</p><p>Foo 类的实现：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world! version one&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// System.out.println(&quot;Hello world! version two&quot;);  // 之后替换成这个</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后我们通过如下程序运行 Foo 类：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token keyword">extends</span> <span class="token class-name">TimerTask</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> basePath <span class="token operator">=</span> <span class="token string">&quot;C:\\\\Users\\\\Bean\\\\IdeaProjects\\\\USTJ\\\\target\\\\classes&quot;</span><span class="token punctuation">;</span>
        <span class="token comment">// 每执行一次任务都 new 一个新的类加载器</span>
        <span class="token class-name">HotswapClassLoader</span> cl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HotswapClassLoader</span><span class="token punctuation">(</span>
            basePath<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;com.jvm.ch7.hotswap.Foo&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment">// 通过我们自己实现的类加载器加载 Foo 类</span>
            <span class="token class-name">Class</span> cls <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">&quot;com.jvm.ch7.hotswap.Foo&quot;</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token class-name">Object</span> foo <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Method</span> method <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">&quot;sayHello&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Class</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        	e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Timer</span> timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="实现类加载器" tabindex="-1"><a class="header-anchor" href="#实现类加载器"><span>实现类加载器</span></a></h3><p><code>HotswapClassLoader</code> 的实现如下，具体的讲解已被写入注释中：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HotswapClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> basePath<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> loadedClass<span class="token punctuation">;</span>  <span class="token comment">// 用来记录被这个类加载器所加载的类</span>

    <span class="token keyword">public</span> <span class="token class-name">HotswapClassLoader</span><span class="token punctuation">(</span><span class="token class-name">String</span> basePath<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 跳过父类加载器，把它设为null</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>basePath <span class="token operator">=</span> basePath<span class="token punctuation">;</span>
        loadedClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 该类加载器在初始化的时候会直接把应该它负责加载的类加载好，</span>
        <span class="token comment">// 这样之后 loadClass 时，会在第一步检验该类是否已经被加载时发现该类已经被加载过了，</span>
        <span class="token comment">// 就无需执行 loadClass 之后的流程，直接返回虚拟机中被加载好的类即可，</span>
        <span class="token comment">// 这样虽然初始化的时间长了点，但是之后 loadClass 时会比较省时间</span>
        <span class="token function">loadClassByMe</span><span class="token punctuation">(</span>classList<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 加载给定的的 classList 中的类到虚拟机
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">loadClassByMe</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> classList<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Class</span> cls <span class="token operator">=</span> <span class="token function">loadClassDirectly</span><span class="token punctuation">(</span>classList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>cls <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                loadedClass<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>classList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 通过文件名直接加载类，得到Class对象
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">loadClassDirectly</span><span class="token punctuation">(</span><span class="token class-name">String</span> className<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Class</span> cls <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>basePath<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> classPath <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">&quot;.&quot;</span><span class="token punctuation">,</span> <span class="token class-name">File</span><span class="token punctuation">.</span>separator<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.class&quot;</span><span class="token punctuation">;</span>
        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token class-name">File</span><span class="token punctuation">.</span>separator <span class="token operator">+</span> classPath<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">File</span> file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">InputStream</span> fin <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            fin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将字节流转化成内存中的Class对象</span>
            cls <span class="token operator">=</span> <span class="token function">instantiateClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> fin<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> file<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> cls<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fin <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 将字节流转化成内存中的Class对象啊，使用defineClass方法！
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Class</span> <span class="token function">instantiateClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">InputStream</span> fin<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span>len<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            fin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fin <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 覆盖原有的loadClass规则，
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">Class</span> <span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Class</span> cls <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token comment">// 应该由 HotswapClassLoader 负责加载的类会通过下面这一行得到类的 Class 对象，</span>
        <span class="token comment">// 因为早在 HotswapClassLoader 类加载器执行构造函数时，它们就被加载好了</span>
        cls <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 只有在这个类没有被加载，且！这个类不是当前这个类加载器负责加载的时候，才去使用启动类加载器</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cls <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>loadedClass<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cls <span class="token operator">=</span> <span class="token function">findSystemClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>cls <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// resolveClass是进行连接操作的，即&quot;验证+准备+解析&quot;，之后就可以进行初始化了</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">resolveClass</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> cls<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,114);function v(m,b){const e=p("ExternalLinkIcon");return l(),o("div",null,[u,n("ul",null,[n("li",null,[s("指向"),n("a",d,[s("运行时常量池"),c(e)]),s("中该栈帧所属方法的引用；")]),k]),r])}const y=t(i,[["render",v],["__file","JVM学习-字节码执行引擎.html.vue"]]),w=JSON.parse('{"path":"/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html","title":"字节码执行引擎","lang":"zh-CN","frontmatter":{"title":"字节码执行引擎","icon":"lightbulb","description":"一、执行引擎 在Java虚拟机的概念模型中，执行引擎是负责执行虚拟机中的字节码指令集的组件。执行引擎的工作涉及到方法的调用和字节码的执行。在不同的虚拟机实现中，执行引擎的具体实现方式可能会有所不同，但从外观上看，其输入和输出是一致的。执行引擎接收字节码的二进制流作为输入，经过处理执行字节码指令，然后输出执行结果。 执行引擎的工作方式通常包括解释执行和编...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.html"}],["meta",{"property":"og:site_name","content":"疼了也不哭"}],["meta",{"property":"og:title","content":"字节码执行引擎"}],["meta",{"property":"og:description","content":"一、执行引擎 在Java虚拟机的概念模型中，执行引擎是负责执行虚拟机中的字节码指令集的组件。执行引擎的工作涉及到方法的调用和字节码的执行。在不同的虚拟机实现中，执行引擎的具体实现方式可能会有所不同，但从外观上看，其输入和输出是一致的。执行引擎接收字节码的二进制流作为输入，经过处理执行字节码指令，然后输出执行结果。 执行引擎的工作方式通常包括解释执行和编..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"字节码执行引擎\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"2.1局部变量表","slug":"_2-1局部变量表","link":"#_2-1局部变量表","children":[{"level":3,"title":"局部变量表的空间分配","slug":"局部变量表的空间分配","link":"#局部变量表的空间分配","children":[]},{"level":3,"title":"Slot 的复用","slug":"slot-的复用","link":"#slot-的复用","children":[]}]},{"level":2,"title":"2.2操作数栈","slug":"_2-2操作数栈","link":"#_2-2操作数栈","children":[]},{"level":2,"title":"2.3动态连接","slug":"_2-3动态连接","link":"#_2-3动态连接","children":[]},{"level":2,"title":"2.4方法返回地址","slug":"_2-4方法返回地址","link":"#_2-4方法返回地址","children":[]},{"level":2,"title":"2.5附加信息","slug":"_2-5附加信息","link":"#_2-5附加信息","children":[]},{"level":2,"title":"3.1字节码指令","slug":"_3-1字节码指令","link":"#_3-1字节码指令","children":[]},{"level":2,"title":"3.2解析调用","slug":"_3-2解析调用","link":"#_3-2解析调用","children":[]},{"level":2,"title":"3.3分派解析","slug":"_3-3分派解析","link":"#_3-3分派解析","children":[{"level":3,"title":"静态分派（方法重载）","slug":"静态分派-方法重载","link":"#静态分派-方法重载","children":[]},{"level":3,"title":"动态分派（方法重写）","slug":"动态分派-方法重写","link":"#动态分派-方法重写","children":[]},{"level":3,"title":"字段没有多态性","slug":"字段没有多态性","link":"#字段没有多态性","children":[]}]},{"level":2,"title":"3.4单分派与多分派","slug":"_3-4单分派与多分派","link":"#_3-4单分派与多分派","children":[]},{"level":2,"title":"3.5总结","slug":"_3-5总结","link":"#_3-5总结","children":[{"level":3,"title":"java.lang.invoke 包","slug":"java-lang-invoke-包","link":"#java-lang-invoke-包","children":[]},{"level":3,"title":"invokedynamic 指令","slug":"invokedynamic-指令","link":"#invokedynamic-指令","children":[]}]},{"level":2,"title":"解释执行","slug":"解释执行","link":"#解释执行","children":[]},{"level":2,"title":"指令集分类","slug":"指令集分类","link":"#指令集分类","children":[{"level":3,"title":"基于栈的指令集","slug":"基于栈的指令集","link":"#基于栈的指令集","children":[]},{"level":3,"title":"基于寄存器的指令集","slug":"基于寄存器的指令集","link":"#基于寄存器的指令集","children":[]}]},{"level":2,"title":"执行过程分析","slug":"执行过程分析","link":"#执行过程分析","children":[]},{"level":2,"title":"什么是热替换及其实现原理","slug":"什么是热替换及其实现原理","link":"#什么是热替换及其实现原理","children":[]},{"level":2,"title":"实现简单的 Java 类热替换","slug":"实现简单的-java-类热替换","link":"#实现简单的-java-类热替换","children":[{"level":3,"title":"需求分析","slug":"需求分析","link":"#需求分析","children":[]},{"level":3,"title":"实现类加载器","slug":"实现类加载器","link":"#实现类加载器","children":[]}]}],"git":{},"readingTime":{"minutes":26.51,"words":7953},"filePathRelative":"book/深入理解Java虚拟机/JVM学习-字节码执行引擎.md","autoDesc":true}');export{y as comp,w as data};
