import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as l,c as i,b as n,e as s,f as t,d as e}from"./app-D1py-eEI.js";const c={},r=n("h1",{id:"一、前端编译与优化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#一、前端编译与优化"},[n("span",null,"一、前端编译与优化")])],-1),u={href:"https://gaoyubo.cn/blogs/89d6d9be.html",target:"_blank",rel:"noopener noreferrer"},d=e(`<p>Java技术下讨论“编译期”需要结合具体上下文语境，因为它可能存在很多种情况：</p><ul><li><p>前端编译器（叫“编译器的前端”更准确一些）把<code>.java文件</code>转变成<code>.class文件</code>的过程</p><p>JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</p></li><li><p>即时编译器（常称JIT编译器，Just In Time Compiler）运行期<strong>把字节码转变成本地机器码</strong>的过程</p><p>HotSpot虚拟机的C1、C2编译器，Graal编译器</p></li><li><p>提前编译器（常称AOT编译器，Ahead Of Time Compiler）直接<strong>把程序编译成与目标机器指令集相关的二进制代码</strong>的过程</p><p>JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET 。</p></li></ul><p>本章标题中的“前端”指的是由<strong>前端编译器</strong>完成的编译行为，对于前端编译优化，有以下说法：</p><ol><li><p>前端编译器对代码的运行效率几乎没有任何优化措施可言</p></li><li><p>Java虚拟机设计团队选择把对<strong>性能的优化全部集中到运行期的即时编译器</strong>中</p><p>这样可以让那些不是由Javac产生的Class文件也同样能享受到编译器优化措施所带来的性能红利</p></li><li><p>相当多新生的Java语法特性，都是靠编译器的“语法糖”来实现，而不是依赖字节码或者Java虚拟机的底层改进来支持。</p></li><li><p>Java中即时编译器在运行期的优化过程，支撑了程序执行效率的不断提升；</p></li><li><p>前端编译器在编译期的优化过程，支撑着程序员的编码效率和语言使用者的幸福感的提高</p></li></ol><h2 id="_1-1javac编译器" tabindex="-1"><a class="header-anchor" href="#_1-1javac编译器"><span>1.1Javac编译器</span></a></h2><p>从Javac源代码的总体结构来看，编译过程大致可以分为<strong>1个准备过程和3个处理过程</strong>，它们分别如下所示：</p><ol><li><p>准备过程：初始化插入式注解处理器</p></li><li><p>解析与填充符号表过程，包括：</p><p>​ 词法、语法分析：将源代码的字符流转变为标记集合，构造出抽象语法树</p><p>​ 填充符号表：产生符号地址和符号信息</p></li><li><p>插入式注解处理器的注解处理过程：插入式注解处理器的执行阶段</p></li><li><p>分析与字节码生成过程，包括：</p><p>标注检查：对语法的静态信息进行检查。</p><p>数据流及控制流分析：对程序动态运行过程进行检查。</p><p>解语法糖：将简化代码编写的语法糖还原为原有的形式。</p><p>字节码生成：将前面各个步骤所生成的信息转化成字节码。</p></li><li><p>对于以上过程：执行插入式注解时又可能会产生新的符号，如果有新的符号产生，就必须转 回到之前的解析、填充符号表的过程中重新处理这些新符号</p></li><li><p>整个编译过程主要的处理由图中标注的8个方法来完成</p></li></ol><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/23/bb75abafae4575a1341040b2903f13ab.png" style="zoom:50%;"><h3 id="解析和填充符号表" tabindex="-1"><a class="header-anchor" href="#解析和填充符号表"><span>解析和填充符号表</span></a></h3><h4 id="词法语法分析" tabindex="-1"><a class="header-anchor" href="#词法语法分析"><span>词法语法分析</span></a></h4><p><strong>1.词法分析</strong>：词法分析是将源代码的字符流转变为标记（Token）集合的过程。</p><p><strong>2.语法分析</strong>：语法分析是根据标记序列构造抽象语法树的过程</p><ul><li><p>抽象语法树：抽象语法树（Abstract Syntax Tree，AST）是一 种用来<strong>描述程序代码语法结构的树形表示方式</strong>，抽象语法树的每一个节点都代表着程序代码中的一个语法结构</p></li><li><p>包、类型、修饰符、运算符、接口、返回值甚至连代码注释等都可以是一种特定的语法结构。</p></li><li><p>抽象语法树可通过Eclipse AST View插件查看，抽象语法树是以com.sun.tools.javac.tree.JCTree 类表示的</p></li><li><p>经过词法和语法分析生成语法树以后，编译器就不会再对源码字符流进行操作了，<strong>后续的操作都建立在抽象语法树之上</strong></p></li></ul><h3 id="填充符号表" tabindex="-1"><a class="header-anchor" href="#填充符号表"><span>填充符号表</span></a></h3><p>符号表（Symbol Table）是由一组符号地址和符号信息构成的数据结构（可以理解成哈希表中的键值对的存储形式）</p><p>符号表中所登记的信息在编译的不同阶段都要被用到：</p><ul><li>语义分析的过程中，符号表所登记的内容将用于语义检查 （如检查一个名字的使用和原先的声明是否一致）和产生中间代码</li><li>目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的直接依据。</li></ul><h3 id="注解处理器" tabindex="-1"><a class="header-anchor" href="#注解处理器"><span><strong>注解处理器</strong></span></a></h3><p>可以把<strong>插入式注解处理器</strong>看作是一组编译器的插件，当这些插件工作时，允许读取、修改、添加抽象语法树中的任意元素。</p><p>譬如Java著名的编码效率工具Lombok，它可以通过注解来实现自动产生 getter/setter方法、进行空置检查、生成受查异常表、产生equals()和hashCode()方法，等等.</p><h3 id="语义分析与字节码生成" tabindex="-1"><a class="header-anchor" href="#语义分析与字节码生成"><span>语义分析与字节码生成</span></a></h3><p>语义分析的主要任务则是对结构上正确的源 程序进行上下文相关性质的检查，譬如进行<strong>类型检查、控制流检查、数据流检查</strong>，等等</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">boolean</span> b <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token comment">//后续可能出现的赋值运算：</span>

<span class="token keyword">int</span> d <span class="token operator">=</span> a <span class="token operator">+</span> c<span class="token punctuation">;</span> 
<span class="token keyword">int</span> d <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span> <span class="token comment">//错误，</span>
<span class="token keyword">char</span> d <span class="token operator">=</span> a <span class="token operator">+</span> c<span class="token punctuation">;</span> <span class="token comment">//错误</span>

<span class="token comment">//C语言中，a、b、c的上下文定义不变，第二、三种写法都是可以被正确编译的</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>我们编码时经常能在IDE 中看到由红线标注的错误提示，其中绝大部分都是来源于语义分析阶段的检查结果。</p></blockquote><h4 id="_1-标注检查" tabindex="-1"><a class="header-anchor" href="#_1-标注检查"><span>1.标注检查</span></a></h4><p>标注检查步骤要检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配，等等，刚才3个变量定义的例子就属于标注检查的处理范畴</p><p>在标注检查中，还会顺便进行 一个称为常量折叠（Constant Folding）的代码优化，这是Javac编译器会对源代码做的极少量优化措施 之一（代码优化几乎都在即时编译器中进行）。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>int a = 2 + 1;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/23/3d5879de02d9a355c9c9f4b06576e61d.png" style="zoom:67%;"><blockquote><p>由于编译期间进行了常量折叠，所以在代码里面定 义“a=1+2”比起直接定义“a=3”来，并不会增加程序运行期哪怕仅仅一个处理器时钟周期的处理工作量。</p></blockquote><h4 id="_2-数据及控制流分析" tabindex="-1"><a class="header-anchor" href="#_2-数据及控制流分析"><span>2.数据及控制流分析</span></a></h4><p>可以检查出诸如程序局部变量 <strong>在使用前是否有赋值</strong>、方法的<strong>每条路径是否都有返回值</strong>、是否所有的受查异常都被正确处理了等问题。</p><h4 id="_3-解语法糖" tabindex="-1"><a class="header-anchor" href="#_3-解语法糖"><span>3.解语法糖</span></a></h4><p>在Javac的源码中，解语法糖的过程由desugar()方法触发。</p><blockquote><p>Java中最常见的语法糖包括了前面提到过的泛型、变长参数、自动装箱拆箱，等等。</p></blockquote><h4 id="_4-字节码生成" tabindex="-1"><a class="header-anchor" href="#_4-字节码生成"><span>4.字节码生成</span></a></h4><p>字节码生成是Javac编译过程的最后一个阶段，在Javac源码里面由com.sun.tools.javac.jvm.Gen类来完成。</p><p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘中，编译器还进行了少量的代码添加和转换工作。</p><blockquote><p>实例构造器()方法和类构造器()方法就是在这个阶段被添加到语 法树之中的</p><p>字符串的加操作替换为StringBuffer或StringBuilder（取决于目标代码的版本是否大于或等于JDK 5）的append()操 作，等等。</p></blockquote><h2 id="_1-2语法糖的本质" tabindex="-1"><a class="header-anchor" href="#_1-2语法糖的本质"><span>1.2语法糖的本质</span></a></h2><h3 id="泛型" tabindex="-1"><a class="header-anchor" href="#泛型"><span>泛型</span></a></h3><p>泛型的本质是参数化类型或者参数化多态的应用，即可以将操作的数据类型指定为方法签名中的一种特殊参数。</p><p>Java选择的泛型实现方式叫作<code>类型擦除式泛型</code>：Java语言中的泛型只在程序源码中存在，在编译后的字节码文件中，全部泛型都被替换为原来的<strong>裸类型</strong>了，并且在相应的地方插入了强制转型代码。</p><h4 id="类型擦除" tabindex="-1"><a class="header-anchor" href="#类型擦除"><span>类型擦除</span></a></h4><p><strong>裸类型”</strong>（Raw Type）的概念：裸类型应被视为所有该类型泛型化实例的共同父类型（Super Type）</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> ilist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> slist <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">ArrayList</span> list<span class="token punctuation">;</span> <span class="token comment">// 裸类型</span>
list <span class="token operator">=</span> ilist<span class="token punctuation">;</span>
list <span class="token operator">=</span> slist<span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>如何实现裸类型？</strong></p><p>直接在编译时把<code>ArrayList&lt;Integer&gt;</code>通过类型擦除还原回ArrayList，只在元素访问、修改时自动插入一些强制类型转换和检查指令</p><p>泛型擦除前的例子</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;吃了没？&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把这段Java代码编译成Class文件，然后再用字节码反编译工具进行反编译后，将会发现泛型都不见了</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Map</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//裸类型</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;你好&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;吃了没？&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//强制类型转换</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;how are you?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>当泛型遇到重载</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GenericTypes</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;String&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;invoke method(List&lt;Integer&gt; list)&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,54),k={href:"https://gaoyubo.cn/blogs/844dc0e7.html?highlight=%E7%89%B9%E5%BE%81%E7%AD%BE%E5%90%8D#class%E6%96%87%E4%BB%B6%E4%B8%AD%E7%A4%BA%E4%BE%8B-2",target:"_blank",rel:"noopener noreferrer"},v=n("code",null,"List list",-1),m=e(`<img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/23/c22f3050c01be15744d8b6ad77419ab6.png" style="zoom:50%;"><h4 id="自动装箱、拆箱与遍历循环" tabindex="-1"><a class="header-anchor" href="#自动装箱、拆箱与遍历循环"><span>自动装箱、拆箱与遍历循环</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">List</span> list <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Iterator</span> localIterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> localIterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span>localIterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="二、后端编译与优化" tabindex="-1"><a class="header-anchor" href="#二、后端编译与优化"><span>二、后端编译与优化</span></a></h1><p>如果把字节码看作是程序语言的一种中间表示形式（Intermediate Representation，IR）的话， 那编译器无论在何时、在何种状态下把<strong>Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码</strong>，都可以视为整个编译过程的后端</p><h2 id="_2-1即时编译器" tabindex="-1"><a class="header-anchor" href="#_2-1即时编译器"><span>2.1即时编译器</span></a></h2><p>由于<strong>即时编译器编译本地代码需要占用程序运行时间</strong>，通常要编译出优化程度越高的代码，所花费的时间便会越长； 而且想要编译出优化程度更高的代码，解释器可能还要替编译器收集性能监控信息，这对解释执行阶段的速度也有所影响。 <strong>为了在程序启动响应速度与运行效率之间达到最佳平衡：</strong></p><p>HotSpot虚拟机在编译子系统中加入了分层编译的功能，分层编译根据编译器编译、优化的规模与耗时，划分出不同的编译层次，其中包 括：</p><ul><li>第0层。程序纯解释执行，并且解释器不开启性能监控功能（Profiling）。</li><li>第1层。使用客户端编译器将字节码编译为本地代码来运行，进行简单可靠的稳定优化，不开启 性能监控功能。</li><li>第2层。仍然使用客户端编译器执行，仅开启方法及回边次数统计等有限的性能监控功能。</li><li>第3层。仍然使用客户端编译器执行，开启全部性能监控，除了第2层的统计信息外，还会收集如分支跳转、虚方法调用版本等全部的统计信息。</li><li>第4层。使用服务端编译器将字节码编译为本地代码，相比起客户端编译器，服务端编译器会启 用更多编译耗时更长的优化，还会根据性能监控信息进行一些不可靠的激进优化。</li></ul><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/22/e2d911a20383f8cbab46d914f53ed80a.png" style="zoom:50%;"><h3 id="编译对象与触发条件" tabindex="-1"><a class="header-anchor" href="#编译对象与触发条件"><span>编译对象与触发条件</span></a></h3><p>会被即时编译器编译的目标是<code>热点代码</code>，这里所指的热点代码主要有两类：</p><ul><li>被<strong><em>多次</em>调用的方法。</strong></li><li>被<strong><em>多次</em>执行的循环体。</strong></li></ul><p><strong>对于这两种情况，编译的目标对象都是整个方法体，而不会是单独的循环体。</strong></p><p>这种编译方式因为 编译发生在方法执行的过程中，因此被很形象地称为<code>栈上替换</code>（On Stack Replacement，OSR），即方法的栈帧还在栈上，方法就被替换了。</p><h4 id="多少次才算-多次-呢" tabindex="-1"><a class="header-anchor" href="#多少次才算-多次-呢"><span>多少次才算“多次”呢？</span></a></h4><p>要知道某段代码是不是热点代码，是不是需要触发即时编译，这个行为称为“热点探测”（Hot Spot Code Detection），判定方式：</p><ol><li><p><strong>基于采样的热点探测（Sample Based Hot Spot Code Detection）</strong></p><p>会周期性地检查各个线程的调用栈顶，如果发现<strong>某个方法经常出现在栈顶，那这个方法就是<code>热点方法</code>。</strong></p><p>缺点：很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而 扰乱热点探测</p></li><li><p><strong>基于计数器的热点探测（Counter Based Hot Spot Code Detection）</strong></p><p>为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果<strong>执行次数超过一定的阈值就认为它是<code>热点方法</code></strong>。</p><p>缺点：实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能 直接获取到方法的调用关系</p></li></ol><blockquote><p>J9用过第一种采样热点探测，而在HotSpot 虚拟机中使用的是第二种基于计数器的热点探测方法，</p></blockquote><h4 id="hotspot-中每个方法的-2-个计数器" tabindex="-1"><a class="header-anchor" href="#hotspot-中每个方法的-2-个计数器"><span>HotSpot 中每个方法的 2 个计数器</span></a></h4><ul><li><strong>方法调用计数器</strong><ul><li>统计方法被调用的次数，处理多次调用的方法的。</li><li>默认统计的不是方法调用的绝对次数，而是方法在一段时间内被调用的次数，如果超过这个时间限制还没有达到判为热点代码的阈值，则该方法的调用计数器值减半。 <ul><li>关闭热度衰减：<code>-XX: -UseCounterDecay</code>（此时方法计数器统计的是方法被调用的绝对次数）；</li><li>设置半衰期时间：<code>-XX: CounterHalfLifeTime</code>（单位是秒）；</li><li>热度衰减过程是在 GC 时顺便进行。</li><li>默认阈值在客户端模式下是1500次，在服务端模式下是10000次，</li></ul></li></ul></li><li><strong>回边计数器</strong><ul><li>统计一个方法中 “回边” 的次数，处理多次执行的循环体的。 <ul><li>回边：在字节码中遇到控制流向后跳转的指令（不是所有循环体都是回边，空循环体是自己跳向自己，没有向后跳，不算回边）。</li></ul></li><li>调整回边计数器阈值：<code>-XX: OnStackReplacePercentage</code>（OSR比率） <ul><li>Client 模式：<code>回边计数器的阈值 = 方法调用计数器阈值 * OSR比率 / 100</code>；</li><li>Server 模式：<code>回边计数器的阈值 = 方法调用计数器阈值 * ( OSR比率 - 解释器监控比率 ) / 100</code>；</li></ul></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/22/5cf6496226e33b90c9058391c75234d0.png" style="zoom:50%;"><h3 id="编译过程" tabindex="-1"><a class="header-anchor" href="#编译过程"><span>编译过程</span></a></h3><p>虚拟机在代码编译未完成时会按照解释方式继续执行，<strong>编译动作在后台的编译线程执行。</strong></p><p>禁止后台编译：<code>-XX: -BackgroundCompilation</code>，打开后这个开关参数后，交编译请求的线程会等待编译完成，然后执行编译器输出的本地代码。</p><p>在后台编译过程中，客户端编译器与服务端编译器是有区别的。</p><h4 id="客户端编译器" tabindex="-1"><a class="header-anchor" href="#客户端编译器"><span>客户端编译器</span></a></h4><p>是一个相对简单快速的三段式编译器，主要的<strong>关注点在于局部性的优化</strong>，而放弃了许多耗时较长的全局优化手段。</p><ol><li><p>第一个阶段，一个平台独立的前端将字节码构造成一种高级中间代码表示（High-Level Intermediate Representation，HIR，即与目标机器指令集无关的中间表示）。HIR使用静态单分配 （Static Single Assignment，SSA）的形式来代表代码值，这可以使得一些在HIR的构造过程之中和之后进行的优化动作更容易实现。在此之前编译器已经会在字节码上完成一部分基础优化，<strong>如方法内联、 常量传播等优化将会在字节码被构造成HIR之前完成。</strong></p></li><li><p>第二个阶段，一个平台相关的后端从HIR中产生低级中间代码表示（Low-Level Intermediate Representation，LIR，即与目标机器指令集相关的中间表示），而在此之前会在HIR上完成另外一些优化，如空值检查消除、范围检查消除等，以便让HIR达到更高效的代码表示形式。</p></li><li><p>最后的阶段是在平台相关的后端使用线性扫描算法（Linear Scan Register Allocation）在LIR上分配寄存器，并在LIR上做窥孔（Peephole）优化，然后产生机器代码。客户端编译器大致的执行过程如图</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-程序编译与优化/2023/12/22/545057793d7a0d911250ca68a4bd6814.png" style="zoom:50%;"></li></ol><h4 id="服务端编译器" tabindex="-1"><a class="header-anchor" href="#服务端编译器"><span>服务端编译器</span></a></h4><p>是专门面向服务端的典型应用场景，执行大部分经典的优化动作，如：无用代码消除（Dead Code Elimination）、循环展开 （Loop Unrolling）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、常量传播（Constant Propagation）、基本块重排序（Basic Block Reordering）等，还会实施一些与Java语言特性密切相关的优化技术，如范围检查消除（Range Check Elimination）、空值检查消除（Null Check Elimination，不过并非所有的空值检查消除都是依赖编译器优化的，有一些是代码运行过程中自动优化了）等。</p><p>另外，还可能根据解释器或客户端编译器提供的 性能监控信息，进行一些不稳定的预测性激进优化，如守护内联（Guarded Inlining）、分支频率预测 （Branch Frequency Prediction）等</p><p>服务端编译采用的寄存器分配器是一个全局图着色分配器，它可以充分利用某些处理器架构（如 RISC）上的大寄存器集合。</p><h2 id="_2-2提前编译器" tabindex="-1"><a class="header-anchor" href="#_2-2提前编译器"><span>2.2提前编译器</span></a></h2><p>现在提前编译产品和对其的研究有着两条明显的分支：</p><ol><li><p>与传统C、C++编译器类似的，在<strong>程序运行之前把程序代码编译成机器码的静态翻译工作</strong></p></li><li><p>把原本<strong>即时编译器在运行时要做的编译工作提前做好并保存下来</strong>，下次运行到这些代码（譬如公共库代码在被同一台机器其他Java进程使用）时直接把它加载进来使用。(本质是给即时编译器做缓存加速，去改善Java程序的启动时间)</p><blockquote><p>在目前的Java技术体系里，这种提前编译已经完全被主流的商用JDK支持</p><p>困难：这种提前编译方式不仅要和目标机器相关，甚至还必须与HotSpot虚拟机的运行时参数绑定（如生成内存屏障代码）才能正确工作，要做提前编译的话，自然也要把这些配合的工作平移过去。</p></blockquote></li></ol><h2 id="_2-3即时编译器的优势" tabindex="-1"><a class="header-anchor" href="#_2-3即时编译器的优势"><span>2.3即时编译器的优势</span></a></h2><p>提前编译的代码输出质量，一定会比即时编译更高吗？</p><p>以下为即时编译器相较于提前编译器的优势：</p><ol><li><p><strong>性能分析制导优化（Profile-Guided Optimization，PGO）</strong></p><p><strong>抽象类通常会是什么实际类型、条件判断通常会走哪条分支、方法调用通常会选择哪个版本、循环通常会进行多少次等</strong>，这些数据一般在静态分析时是无法得到的，或者不可能存在确定且唯一的解， 最多只能依照一些启发性的条件去进行猜测。但**在动态运行时却能看出它们具有非常明显的偏好性。**就可以把热的代码集中放到 一起，集中优化和分配更好的资源（分支预测、寄存器、缓存等）给它。</p></li><li><p><strong>激进预测性优化（Aggressive Speculative Optimization）</strong></p><p>静态优化无论如何都必须保证优化后所有的程序外部可见影响（不仅仅是执行结果） 与优化前是等效的</p><p>然而，即时编译的策略就可以不必这样保守，<strong>可以大胆地按照高概率的假设进行优化</strong>，万一真的走到罕见分支上，大不了退回到低级编译器甚至解释器上去执行，并不会出现无法挽救的后果。</p><blockquote><p>如果Java虚拟机真的遇到虚方法就去查虚表而不做内 联的话，Java技术可能就已经因性能问题而被淘汰很多年了。</p><p>实际上虚拟机会通过类继承关系分析等 一系列激进的猜测去做去虚拟化（Devitalization），以保证绝大部分有内联价值的虚方法都可以顺利内联。</p></blockquote></li><li><p><strong>链接时优化（Link-Time Optimization，LTO）</strong></p><p>如C、C++的程序要调用某个动态链接库的某个方法，就会出现很明显的边界隔阂，还难以优化。 这是因为主程序与动态链接库的代码在它们编译时是完全独立的，两者各自编译、优化自己的代码。</p><p>然而，<strong>Java语言天生就是动态链接的</strong>，一个个 Class文件在运行期被加载到虚拟机内存当中。</p></li></ol><h1 id="三、编译器优化技术" tabindex="-1"><a class="header-anchor" href="#三、编译器优化技术"><span>三、编译器优化技术</span></a></h1><table><thead><tr><th>类型</th><th>优化技术</th></tr></thead><tbody><tr><td><strong>编译器策略 (Compiler Tactics)</strong></td><td></td></tr><tr><td></td><td>延迟编译 (Delayed Compilation)</td></tr><tr><td></td><td>分层编译 (Tiered Compilation)</td></tr><tr><td></td><td>栈上替换 (On-Stack Replacement)</td></tr><tr><td></td><td>延迟优化 (Delayed Reoptimization)</td></tr><tr><td></td><td>静态单赋值表示 (Static Single Assignment Representation)</td></tr><tr><td><strong>基于性能监控的优化技术 (Profile-Based Techniques)</strong></td><td></td></tr><tr><td></td><td>乐观空值断言 (Optimistic Nullness Assertions)</td></tr><tr><td></td><td>乐观类型断言 (Optimistic Type Assertions)</td></tr><tr><td></td><td>乐观类型增强 (Optimistic Type Strengthening)</td></tr><tr><td></td><td>乐观数组长度增强 (Optimistic Array Length Strengthening)</td></tr><tr><td></td><td>裁剪未被选择的分支 (Untaken Branch Pruning)</td></tr><tr><td></td><td>乐观的多态内联 (Optimistic N-morphic Inlining)</td></tr><tr><td></td><td>分支频率预测 (Branch Frequency Prediction)</td></tr><tr><td></td><td>调用频率预测 (Call Frequency Prediction)</td></tr><tr><td><strong>基于证据的优化技术 (Proof-Based Techniques)</strong></td><td></td></tr><tr><td></td><td>精确类型推断 (Exact Type Inference)</td></tr><tr><td></td><td>内存值推断 (Memory Value Inference)</td></tr><tr><td></td><td>内存值跟踪 (Memory Value Tracking)</td></tr><tr><td></td><td>常量折叠 (Constant Folding)</td></tr><tr><td></td><td>重组 (Reassociation)</td></tr><tr><td></td><td>操作符退化 (Operator Strength Reduction)</td></tr><tr><td></td><td>空值检查消除 (Null Check Elimination)</td></tr><tr><td></td><td>类型检测退化 (Type Test Strength Reduction)</td></tr><tr><td></td><td>类型检测消除 (Type Test Elimination)</td></tr><tr><td></td><td>代数简化 (Algebraic Simplification)</td></tr><tr><td></td><td>公共子表达式消除 (Common Subexpression Elimination)</td></tr><tr><td><strong>数据流敏感重写 (Flow-Sensitive Rewrites)</strong></td><td></td></tr><tr><td></td><td>条件常量传播 (Conditional Constant Propagation)</td></tr><tr><td></td><td>基于流承载的类型缩减转换 (Flow-Carried Type Narrowing)</td></tr><tr><td></td><td>无用代码消除 (Dead Code Elimination)</td></tr><tr><td><strong>语言相关的优化技术 (Language-Specific Techniques)</strong></td><td></td></tr><tr><td></td><td>类型继承关系分析 (Class Hierarchy Analysis)</td></tr><tr><td></td><td>去虚拟化 (Devirtualization)</td></tr><tr><td></td><td>符号常量传播 (Symbolic Constant Propagation)</td></tr><tr><td></td><td>自动装箱消除 (Autobox Elimination)</td></tr><tr><td></td><td>逃逸分析 (Escape Analysis)</td></tr><tr><td></td><td>锁消除 (Lock Elision)</td></tr><tr><td></td><td>锁膨胀 (Lock Coarsening)</td></tr><tr><td></td><td>消除反射 (De-reflection)</td></tr><tr><td><strong>内存及代码位置变换 (Memory and Placement Transformation)</strong></td><td></td></tr><tr><td></td><td>表达式提升 (Expression Hoisting)</td></tr><tr><td></td><td>表达式下沉 (Expression Sinking)</td></tr><tr><td></td><td>冗余存储消除 (Redundant Store Elimination)</td></tr><tr><td></td><td>相邻存储合并 (Adjacent Store Fusion)</td></tr><tr><td></td><td>交汇点分离 (Merge-Point Splitting)</td></tr><tr><td><strong>循环变换 (Loop Transformations)</strong></td><td></td></tr><tr><td></td><td>循环展开 (Loop Unrolling)</td></tr><tr><td></td><td>循环剥离 (Loop Peeling)</td></tr><tr><td></td><td>安全点消除 (Safepoint Elimination)</td></tr><tr><td></td><td>迭代范围分离 (Iteration Range Splitting)</td></tr><tr><td></td><td>范围检查消除 (Range Check Elimination)</td></tr><tr><td></td><td>循环向量化 (Loop Vectorization)</td></tr><tr><td><strong>全局代码调整 (Global Code Shaping)</strong></td><td></td></tr><tr><td></td><td>内联 (Inlining)</td></tr><tr><td></td><td>全局代码外提 (Global Code Motion)</td></tr><tr><td></td><td>基于热度的代码布局 (Heat-Based Code Layout)</td></tr><tr><td></td><td>Switch调整 (Switch Balancing)</td></tr><tr><td><strong>控制流图变换 (Control Flow Graph Transformation)</strong></td><td></td></tr><tr><td></td><td>本地代码编排 (Local Code Scheduling)</td></tr><tr><td></td><td>本地代码封包 (Local Code Bundling)</td></tr><tr><td></td><td>延迟槽填充 (Delay Slot Filling)</td></tr><tr><td></td><td>着色图寄存器分配 (Graph-Coloring Register Allocation)</td></tr><tr><td></td><td>线性扫描寄存器分配 (Linear Scan Register Allocation)</td></tr><tr><td></td><td>复写聚合 (Copy Coalescing)</td></tr><tr><td></td><td>常量分裂 (Constant Splitting)</td></tr><tr><td></td><td>复写移除 (Copy Removal)</td></tr><tr><td></td><td>地址模式匹配 (Address Mode Matching)</td></tr><tr><td></td><td>指令窥空优化 (Instruction Peepholing)</td></tr><tr><td></td><td>基于确定有限状态机的代码生成 (DFA-Based Code Generator)</td></tr></tbody></table><h2 id="_3-1一个优化的例子" tabindex="-1"><a class="header-anchor" href="#_3-1一个优化的例子"><span>3.1一个优化的例子</span></a></h2><p><strong>原始代码：</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    z <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第一步优化：</strong> 方法内联（一般放在优化序列最前端，因为对其他优化有帮助）</p><p><strong>目的：</strong></p><ul><li>去除方法调用的成本（如建立栈帧等）</li><li>为其他优化建立良好的基础</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    z <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第二步优化：</strong> 公共子表达式消除</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...  // 因为这部分并没有改变 b.value 的值</span>
                       <span class="token comment">// 如果把 b.value 看成一个表达式，就是公共表达式消除</span>
    z <span class="token operator">=</span> y<span class="token punctuation">;</span>             <span class="token comment">// 把这一步的 b.value 替换成 y</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第三步优化：</strong> 复写传播</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    y <span class="token operator">=</span> y<span class="token punctuation">;</span>             <span class="token comment">// z 变量与以相同，完全没有必要使用一个新的额外变量</span>
                       <span class="token comment">// 所以将 z 替换为 y</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>第四步优化：</strong> 无用代码消除</p><blockquote><p><strong>无用代码：</strong></p><ul><li>永远不会执行的代码</li><li>完全没有意义的代码</li></ul></blockquote><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    y <span class="token operator">=</span> b<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// ...do stuff...</span>
    <span class="token comment">// y = y; 这句没有意义的，去除</span>
    sum <span class="token operator">=</span> y <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3-2方法内联" tabindex="-1"><a class="header-anchor" href="#_3-2方法内联"><span>3.2方法内联</span></a></h2><p>它是<strong>编译器最重要的优化手段</strong>，甚至都可以不加 上“之一”。</p><p>除了消除方法调用的成本之外，它更重要的意义是为其他优化手段建立良好的基础</p><p>目的是：去除方法调用的成本（如建立栈帧等），并为其他优化建立良好的基础，所以一般将方法内联放在优化序列最前端，因为它对其他优化有帮助。</p><blockquote><p>为了解决虚方法的内联问题：引入<strong>类型继承关系分析（Class Hierarchy Analysis，CHA）</strong></p><p>用于确定在目前已加载的类中，某个接口是否有多于一种的实现，某个类是否存在子类、子类是否为抽象类等。</p></blockquote><ul><li><strong>对于非虚方法：</strong><ul><li>直接进行内联，其调用方法的版本在编译时已经确定，是根据变量的静态类型决定的。</li></ul></li><li><strong>对于虚方法：</strong> （激进优化，要预留“逃生门”） <ul><li>向 CHA 查询此方法在当前程序下是否有多个目标可选择； <ul><li>只有一个目标版本： <ul><li>先对这唯一的目标进行内联；</li><li>如果之后的执行中，虚拟机没有加载到会令这个方法接收者的继承关系发生改变的新类，则该内联代码可以一直使用；</li><li>如果加载到导致继承关系发生变化的新类，就抛弃已编译的代码，退回到解释状态进行执行，或者重新进行编译。</li></ul></li><li>有多个目标版本： <ul><li>使用内联缓存，未发生方法调用前，内联缓存为空；</li><li>第一次调用发生后，记录调用方法的对象的版本信息；</li><li>之后的每次调用都要先与内联缓存中的对象版本信息进行比较； <ul><li>版本信息一样，继续使用内联代码，是一种<code>单态内联缓存</code>（Monomorphic Inline Cache）</li><li>版本信息不一样，说明程序使用了虚方法的多态特性，退化成<code>超多态内联缓存</code>（Megamorphic Inline Cache），查找虚方法进行方法分派。</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="_3-3逃逸分析【最前沿】" tabindex="-1"><a class="header-anchor" href="#_3-3逃逸分析【最前沿】"><span>3.3逃逸分析【最前沿】</span></a></h2><h4 id="基本行为" tabindex="-1"><a class="header-anchor" href="#基本行为"><span>基本行为</span></a></h4><p>分析对象的作用域，看它有没有能在当前作用域之外使用：</p><ul><li>方法逃逸：对象在方法中定义之后，能被外部方法引用，如作为参数传递到了其他方法中。</li><li>线程逃逸：赋值给 static 变量，或可以在其他线程中访问的实例变量。</li></ul><h4 id="对于不会逃逸到方法或线程外的对象能进行优化" tabindex="-1"><a class="header-anchor" href="#对于不会逃逸到方法或线程外的对象能进行优化"><span>对于不会逃逸到方法或线程外的对象能进行优化</span></a></h4><ul><li><strong>栈上分配：</strong> 对于不会逃逸到方法外的对象，可以在栈上分配内存，这样这个对象所占用的空间可以随栈帧出栈而销毁，减小 GC 的压力。</li><li><strong>标量替换（重要）：</strong><ul><li>标量：基本数据类型和 reference。</li><li>不创建对象，而是将对象拆分成一个一个标量，然后直接在栈上分配，是栈上分配的一种实现方式。</li><li>HotSpot 使用的是标量替换而不是栈上分配，因为实现栈上分配需要更改大量假设了 “对象只能在堆中分配” 的代码。</li></ul></li><li><strong>同步消除</strong><ul><li>如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，对这个变量实施的同步措施也就可以安全地消除掉。</li></ul></li></ul><h4 id="虚拟机参数" tabindex="-1"><a class="header-anchor" href="#虚拟机参数"><span>虚拟机参数</span></a></h4><ul><li>开启逃逸分析：<code>-XX: +DoEscapeAnalysis</code></li><li>开启标量替换：<code>-XX: +EliminateAnalysis</code></li><li>开启锁消除：<code>-XX: +EliminateLocks</code></li><li>查看分析结果：<code>-XX: PrintEscapeAnalysis</code></li><li>查看标量替换情况：<code>-XX: PrintEliminateAllocations</code></li></ul><h3 id="例子" tabindex="-1"><a class="header-anchor" href="#例子"><span>例子</span></a></h3><p><strong>Point类的代码，这就是一个包含x和y坐标的POJO类型</strong></p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 完全未优化的代码</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span>xx<span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤1：构造函数内联</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token function">point_memory_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在堆中分配P对象的示意方法</span>
    p<span class="token punctuation">.</span>x <span class="token operator">=</span> xx<span class="token punctuation">;</span> <span class="token comment">// Point构造函数被内联后的样子</span>
    p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">.</span>x<span class="token punctuation">;</span> <span class="token comment">// Point::getX()被内联后的样子</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤2：标量替换</p><p>经过逃逸分析，发现在整个test()方法的范围内Point对象实例不会发生任何程度的逃逸， 这样可以对它进行标量替换优化，把其内部的x和y直接置换出来，分解为test()方法内的局部变量，从 而避免Point对象实例被实际创建</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> xx <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> px <span class="token operator">=</span> xx<span class="token punctuation">;</span>
    <span class="token keyword">int</span> py <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> px<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>步骤3：无效代码消除</p><p>通过数据流分析，发现py的值其实对方法不会造成任何影响，那就可以放心地去做无效代码消除得到最终优化结果，</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,83);function g(b,h){const a=o("ExternalLinkIcon");return l(),i("div",null,[r,n("p",null,[s("原文链接："),n("a",u,[s("https://gaoyubo.cn/blogs/89d6d9be.html"),t(a)])]),d,n("p",null,[s("参数列表在"),n("a",k,[s("特征签名"),t(a)]),s("中，因此参数列表不同时，可以进行重载，但是由于所有泛型都需要通过类型擦出转化为裸类型，导致参数都是"),v,s("，所以不能重载。会报错。")]),m])}const x=p(c,[["render",g],["__file","JVM学习-程序编译与优化.html.vue"]]),w=JSON.parse('{"path":"/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html","title":"程序编译与优化","lang":"zh-CN","frontmatter":{"title":"程序编译与优化","icon":"lightbulb","description":"一、前端编译与优化 原文链接：https://gaoyubo.cn/blogs/89d6d9be.html Java技术下讨论“编译期”需要结合具体上下文语境，因为它可能存在很多种情况： 前端编译器（叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程 JDK的Javac、Eclipse JDT中的增量式编译器（ECJ） 即时编译...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BC%98%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"疼了也不哭"}],["meta",{"property":"og:title","content":"程序编译与优化"}],["meta",{"property":"og:description","content":"一、前端编译与优化 原文链接：https://gaoyubo.cn/blogs/89d6d9be.html Java技术下讨论“编译期”需要结合具体上下文语境，因为它可能存在很多种情况： 前端编译器（叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程 JDK的Javac、Eclipse JDT中的增量式编译器（ECJ） 即时编译..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"程序编译与优化\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"1.1Javac编译器","slug":"_1-1javac编译器","link":"#_1-1javac编译器","children":[{"level":3,"title":"解析和填充符号表","slug":"解析和填充符号表","link":"#解析和填充符号表","children":[]},{"level":3,"title":"填充符号表","slug":"填充符号表","link":"#填充符号表","children":[]},{"level":3,"title":"注解处理器","slug":"注解处理器","link":"#注解处理器","children":[]},{"level":3,"title":"语义分析与字节码生成","slug":"语义分析与字节码生成","link":"#语义分析与字节码生成","children":[]}]},{"level":2,"title":"1.2语法糖的本质","slug":"_1-2语法糖的本质","link":"#_1-2语法糖的本质","children":[{"level":3,"title":"泛型","slug":"泛型","link":"#泛型","children":[]}]},{"level":2,"title":"2.1即时编译器","slug":"_2-1即时编译器","link":"#_2-1即时编译器","children":[{"level":3,"title":"编译对象与触发条件","slug":"编译对象与触发条件","link":"#编译对象与触发条件","children":[]},{"level":3,"title":"编译过程","slug":"编译过程","link":"#编译过程","children":[]}]},{"level":2,"title":"2.2提前编译器","slug":"_2-2提前编译器","link":"#_2-2提前编译器","children":[]},{"level":2,"title":"2.3即时编译器的优势","slug":"_2-3即时编译器的优势","link":"#_2-3即时编译器的优势","children":[]},{"level":2,"title":"3.1一个优化的例子","slug":"_3-1一个优化的例子","link":"#_3-1一个优化的例子","children":[]},{"level":2,"title":"3.2方法内联","slug":"_3-2方法内联","link":"#_3-2方法内联","children":[]},{"level":2,"title":"3.3逃逸分析【最前沿】","slug":"_3-3逃逸分析【最前沿】","link":"#_3-3逃逸分析【最前沿】","children":[{"level":3,"title":"例子","slug":"例子","link":"#例子","children":[]}]}],"git":{},"readingTime":{"minutes":25.94,"words":7781},"filePathRelative":"book/深入理解Java虚拟机/JVM学习-程序编译与优化.md","autoDesc":true}');export{x as comp,w as data};
