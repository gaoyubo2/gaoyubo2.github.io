import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as c,o as i,c as p,b as s,e as n,f as e,d as t}from"./app-D1py-eEI.js";const l={},r=t(`<h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><p><strong>抽象工厂模式</strong>是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。</p><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261655870.png" alt="抽象工厂模式" tabindex="0" loading="lazy"><figcaption>抽象工厂模式</figcaption></figure><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><p>假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示：</p><ol><li>一系列相关产品， 例如 <code>椅子</code>Chair 、 <code>沙发</code>Sofa和 <code>咖啡桌</code>Coffee­Table 。</li><li>系列产品的不同变体。 例如， 你可以使用 <code>现代</code>Modern 、 <code>维多利亚</code>Victorian 、 <code>装饰风艺术</code>Art­Deco等风格生成 <code>椅子</code> 、 <code>沙发</code>和 <code>咖啡桌</code> 。</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261655428.png" alt="生成不同风格的系列家具。" tabindex="0" loading="lazy"><figcaption>生成不同风格的系列家具。</figcaption></figure><blockquote><p>系列产品及其不同变体。</p></blockquote><p>你需要设法单独生成每件家具对象， 这样才能确保其风格一致。 如果顾客收到的家具风格不一样， 他们可不会开心。</p><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261656760.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>此外， 你也不希望在添加新产品或新风格时修改已有代码。 家具供应商对于产品目录的更新非常频繁， 你不会想在每次更新时都去修改核心代码的。</p><h2 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案"><span>解决方案</span></a></h2><p>首先， 抽象工厂模式建议为系列中的每件产品明确声明接口 （例如椅子、 沙发或咖啡桌）。 然后， 确保所有产品变体都继承这些接口。 例如， 所有风格的椅子都实现 <code>椅子</code>接口； 所有风格的咖啡桌都实现 <code>咖啡桌</code>接口， 以此类推。</p><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261721986.png" alt="椅子类的层次结构" tabindex="0" loading="lazy"><figcaption>椅子类的层次结构</figcaption></figure><blockquote><p>同一对象的所有变体都必须放置在同一个类层次结构之中。</p></blockquote><p>接下来， 我们需要声明<em>抽象工厂</em>——包含系列中所有产品构造方法的接口。 例如 <code>create­Chair</code>创建椅子 、 <code>create­Sofa</code>创建沙发和 <code>create­Coffee­Table</code>创建咖啡桌 。 这些方法必须返回<strong>抽象</strong>产品类型， 即我们之前抽取的那些接口： <code>椅子</code> ， <code>沙发</code>和 <code>咖啡桌</code>等等。</p><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261722474.png" alt="工厂类的层次结构" tabindex="0" loading="lazy"><figcaption>工厂类的层次结构</figcaption></figure><blockquote><p>每个具体工厂类都对应一个特定的产品变体。</p></blockquote><p>那么该如何处理产品变体呢？ 对于系列产品的每个变体， 我们都将基于 <code>抽象工厂</code>接口创建不同的工厂类。 每个工厂类都只能返回特定类别的产品， 例如， <code>现代家具工厂</code>Modern­Furniture­Factory只能创建 <code>现代椅子</code>Modern­Chair 、 <code>现代沙发</code>Modern­Sofa和 <code>现代咖啡桌</code>Modern­Coffee­Table对象。</p><p>客户端代码可以通过相应的抽象接口调用工厂和产品类。 你无需修改实际客户端代码， 就能更改传递给客户端的工厂类， 也能更改客户端代码接收的产品变体。</p><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261722796.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p>客户端无需了解其所调用工厂的具体类信息。</p></blockquote><p>假设客户端想要工厂创建一把椅子。 客户端无需了解工厂类， 也不用管工厂类创建出的椅子类型。 无论是现代风格， 还是维多利亚风格的椅子， 对于客户端来说没有分别， 它只需调用抽象 <code>椅子</code>接口就可以了。 这样一来， 客户端只需知道椅子以某种方式实现了 <code>sit­On</code>坐下方法就足够了。 此外， 无论工厂返回的是何种椅子变体， 它都会和由同一工厂对象创建的沙发或咖啡桌风格一致。</p><p>最后一点说明： 如果客户端仅接触抽象接口， 那么谁来创建实际的工厂对象呢？ 一般情况下， 应用程序会在初始化阶段创建具体工厂对象。 而在此之前， 应用程序必须根据配置文件或环境设定选择工厂类别。</p><h2 id="抽象工厂模式结构" tabindex="-1"><a class="header-anchor" href="#抽象工厂模式结构"><span>抽象工厂模式结构</span></a></h2><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261722986.png" alt="抽象工厂设计模式" tabindex="0" loading="lazy"><figcaption>抽象工厂设计模式</figcaption></figure><ol><li><strong>抽象产品</strong> （Abstract Product） 为构成系列产品的一组不同但相关的产品声明接口。</li><li><strong>具体产品</strong> （Concrete Product） 是抽象产品的多种不同类型实现。 所有变体 （维多利亚/现代） 都必须实现相应的抽象产品 （椅子/沙发）。</li><li><strong>抽象工厂</strong> （Abstract Factory） 接口声明了一组创建各种抽象产品的方法。</li><li><strong>具体工厂</strong> （Concrete Factory） 实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。</li><li>尽管具体工厂会对具体产品进行初始化， 其构建方法签名必须返回相应的<em>抽象</em>产品。 这样， 使用工厂类的客户端代码就不会与工厂创建的特定产品变体耦合。 <strong>客户端</strong> （Client） 只需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/产品变体交互。</li></ol><h2 id="伪代码" tabindex="-1"><a class="header-anchor" href="#伪代码"><span>伪代码</span></a></h2><p>下面例子通过应用<strong>抽象工厂</strong>模式， 使得客户端代码无需与具体 UI 类耦合， 就能创建跨平台的 UI 元素， 同时确保所创建的元素与指定的操作系统匹配。</p><figure><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261723707.png" alt="抽象工厂模式示例的类图" tabindex="0" loading="lazy"><figcaption>抽象工厂模式示例的类图</figcaption></figure><blockquote><p>跨平台 UI 类示例。</p></blockquote><p>跨平台应用中的相同 UI 元素功能类似， 但是在不同操作系统下的外观有一定差异。 此外， 你需要确保 UI 元素与当前操作系统风格一致。 你一定不希望在 Windows 系统下运行的应用程序中显示 macOS 的控件。</p><p>抽象工厂接口声明一系列构建方法， 客户端代码可调用它们生成不同风格的 UI 元素。 每个具体工厂对应特定操作系统， 并负责生成符合该操作系统风格的 UI 元素。</p><p>其运作方式如下： 应用程序启动后检测当前操作系统。 根据该信息， 应用程序通过与该操作系统对应的类创建工厂对象。 其余代码使用该工厂对象创建 UI 元素。 这样可以避免生成错误类型的元素。</p><p>使用这种方法， 客户端代码只需调用抽象接口， 而无需了解具体工厂类和 UI 元素。 此外， 客户端代码还支持未来添加新的工厂或 UI 元素。</p><p>这样一来， 每次在应用程序中添加新的 UI 元素变体时， 你都无需修改客户端代码。 你只需创建一个能够生成这些 UI 元素的工厂类， 然后稍微修改应用程序的初始代码， 使其能够选择合适的工厂类即可。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 抽象工厂接口声明了一组能返回不同抽象产品的方法。这些产品属于同一个系列</span>
<span class="token comment">// 且在高层主题或概念上具有相关性。同系列的产品通常能相互搭配使用。系列产</span>
<span class="token comment">// 品可有多个变体，但不同变体的产品不能搭配使用。</span>
<span class="token keyword">interface</span> <span class="token class-name">GUIFactory</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span>
    method <span class="token function">createCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Checkbox</span>


<span class="token comment">// 具体工厂可生成属于同一变体的系列产品。工厂会确保其创建的产品能相互搭配</span>
<span class="token comment">// 使用。具体工厂方法签名会返回一个抽象产品，但在方法内部则会对具体产品进</span>
<span class="token comment">// 行实例化。</span>
<span class="token keyword">class</span> <span class="token class-name">WinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">GUIFactory</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WinButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    method <span class="token function">createCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Checkbox</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WinCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 每个具体工厂中都会包含一个相应的产品变体。</span>
<span class="token keyword">class</span> <span class="token class-name">MacFactory</span> <span class="token keyword">implements</span> <span class="token class-name">GUIFactory</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    method <span class="token function">createCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Checkbox</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MacCheckbox</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">// 系列产品中的特定产品必须有一个基础接口。所有产品变体都必须实现这个接口。</span>
<span class="token keyword">interface</span> <span class="token class-name">Button</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 具体产品由相应的具体工厂创建。</span>
<span class="token keyword">class</span> <span class="token class-name">WinButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// 根据 Windows 样式渲染按钮。</span>

<span class="token keyword">class</span> <span class="token class-name">MacButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// 根据 macOS 样式渲染按钮</span>

<span class="token comment">// 这是另一个产品的基础接口。所有产品都可以互动，但是只有相同具体变体的产</span>
<span class="token comment">// 品之间才能够正确地进行交互。</span>
<span class="token keyword">interface</span> <span class="token class-name">Checkbox</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">WinCheckbox</span> <span class="token keyword">implements</span> <span class="token class-name">Checkbox</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// 根据 Windows 样式渲染复选框。</span>

<span class="token keyword">class</span> <span class="token class-name">MacCheckbox</span> <span class="token keyword">implements</span> <span class="token class-name">Checkbox</span> is
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// 根据 macOS 样式渲染复选框。</span>

<span class="token comment">// 客户端代码仅通过抽象类型（GUIFactory、Button 和 Checkbox）使用工厂</span>
<span class="token comment">// 和产品。这让你无需修改任何工厂或产品子类就能将其传递给客户端代码。</span>
<span class="token keyword">class</span> <span class="token class-name">Application</span> is
    <span class="token keyword">private</span> field factory<span class="token operator">:</span> <span class="token class-name">GUIFactory</span>
    <span class="token keyword">private</span> field button<span class="token operator">:</span> <span class="token class-name">Button</span>
    constructor <span class="token class-name">Application</span><span class="token punctuation">(</span>factory<span class="token operator">:</span> <span class="token class-name">GUIFactory</span><span class="token punctuation">)</span> is
        <span class="token keyword">this</span><span class="token punctuation">.</span>factory <span class="token operator">=</span> factory
    method <span class="token function">createUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token keyword">this</span><span class="token punctuation">.</span>button <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    method <span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        button<span class="token punctuation">.</span><span class="token function">paint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">// 程序会根据当前配置或环境设定选择工厂类型，并在运行时创建工厂（通常在初</span>
<span class="token comment">// 始化阶段）。</span>
<span class="token keyword">class</span> <span class="token class-name">ApplicationConfigurator</span> is
    method <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        config <span class="token operator">=</span> <span class="token function">readApplicationConfigFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token constant">OS</span> <span class="token operator">==</span> <span class="token string">&quot;Windows&quot;</span><span class="token punctuation">)</span> then
            factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WinFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token constant">OS</span> <span class="token operator">==</span> <span class="token string">&quot;Mac&quot;</span><span class="token punctuation">)</span> then
            factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MacFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">&quot;错误！未知的操作系统。&quot;</span><span class="token punctuation">)</span>

        <span class="token class-name">Application</span> app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Application</span><span class="token punctuation">(</span>factory<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="抽象工厂模式适合应用场景" tabindex="-1"><a class="header-anchor" href="#抽象工厂模式适合应用场景"><span>抽象工厂模式适合应用场景</span></a></h2><p>如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。</p><p>抽象工厂为你提供了一个接口， 可用于创建每个系列产品的对象。 只要代码通过该接口创建对象， 那么你就不会生成与应用程序已生成的产品类型不一致的产品。</p>`,40),d={href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"},u=t('<p>在设计良好的程序中， <em>每个类仅负责一件事</em>。 如果一个类与多种类型产品交互， 就可以考虑将工厂方法抽取到独立的工厂类或具备完整功能的抽象工厂类中。</p><h2 id="实现方式" tabindex="-1"><a class="header-anchor" href="#实现方式"><span>实现方式</span></a></h2><ol><li>以不同的产品类型与产品变体为维度绘制矩阵。</li><li>为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。</li><li>声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。</li><li>为每种产品变体实现一个具体工厂类。</li><li>在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。</li><li>找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。</li></ol><h2 id="抽象工厂模式优缺点" tabindex="-1"><a class="header-anchor" href="#抽象工厂模式优缺点"><span>抽象工厂模式优缺点</span></a></h2><ul><li>你可以确保同一工厂生成的产品相互匹配。</li><li>你可以避免客户端和具体产品代码的耦合。</li><li><em>单一职责原则</em>。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。</li><li><em>开闭原则</em>。 向应用程序中引入新产品变体时， 你无需修改客户端代码。</li></ul><div class="hint-container warning"><p class="hint-container-title">缺点</p><p>由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。</p></div><h2 id="与其他模式的关系" tabindex="-1"><a class="header-anchor" href="#与其他模式的关系"><span>与其他模式的关系</span></a></h2>',7),k={href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"},m={href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"},g={href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"},h={href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"},v={href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"},b={href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"},f=s("em",null,"抽象工厂",-1),y=s("em",null,"生成器",-1),_={href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"},w={href:"https://refactoringguru.cn/design-patterns/factory-method",target:"_blank",rel:"noopener noreferrer"},B={href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"},x={href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"},E={href:"https://refactoringguru.cn/design-patterns/facade",target:"_blank",rel:"noopener noreferrer"},C={href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"},A={href:"https://refactoringguru.cn/design-patterns/bridge",target:"_blank",rel:"noopener noreferrer"},j=s("em",null,"桥接",-1),I=s("em",null,"抽象工厂",-1),F={href:"https://refactoringguru.cn/design-patterns/abstract-factory",target:"_blank",rel:"noopener noreferrer"},U={href:"https://refactoringguru.cn/design-patterns/builder",target:"_blank",rel:"noopener noreferrer"},M={href:"https://refactoringguru.cn/design-patterns/prototype",target:"_blank",rel:"noopener noreferrer"},q={href:"https://refactoringguru.cn/design-patterns/singleton",target:"_blank",rel:"noopener noreferrer"},S=s("p",null,"文章原文：https://refactoringguru.cn/design-patterns/abstract-factory",-1);function z(W,N){const a=c("ExternalLinkIcon");return i(),p("div",null,[r,s("p",null,[n("如果你有一个基于一组"),s("a",d,[n("抽象方法"),e(a)]),n("的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。")]),u,s("ul",null,[s("li",null,[n("在许多设计工作的初期都会使用"),s("a",k,[n("工厂方法模式"),e(a)]),n(" （较为简单， 而且可以更方便地通过子类进行定制）， 随后演化为使用"),s("a",m,[n("抽象工厂模式"),e(a)]),n("、 "),s("a",g,[n("原型模式"),e(a)]),n("或"),s("a",h,[n("生成器模式"),e(a)]),n(" （更灵活但更加复杂）。")]),s("li",null,[s("a",v,[n("生成器"),e(a)]),n("重点关注如何分步生成复杂对象。 "),s("a",b,[n("抽象工厂"),e(a)]),n("专门用于生产一系列相关对象。 "),f,n("会马上返回产品， "),y,n("则允许你在获取产品前执行一些额外构造步骤。")]),s("li",null,[s("a",_,[n("抽象工厂模式"),e(a)]),n("通常基于一组"),s("a",w,[n("工厂方法"),e(a)]),n("， 但你也可以使用"),s("a",B,[n("原型模式"),e(a)]),n("来生成这些类的方法。")]),s("li",null,[n("当只需对客户端代码隐藏子系统创建对象的方式时， 你可以使用"),s("a",x,[n("抽象工厂"),e(a)]),n("来代替"),s("a",E,[n("外观模式"),e(a)]),n("。")]),s("li",null,[n("你可以将"),s("a",C,[n("抽象工厂"),e(a)]),n("和"),s("a",A,[n("桥接模式"),e(a)]),n("搭配使用。 如果由"),j,n("定义的抽象只能与特定实现合作， 这一模式搭配就非常有用。 在这种情况下， "),I,n("可以对这些关系进行封装， 并且对客户端代码隐藏其复杂性。")]),s("li",null,[s("a",F,[n("抽象工厂"),e(a)]),n("、 "),s("a",U,[n("生成器"),e(a)]),n("和"),s("a",M,[n("原型"),e(a)]),n("都可以用"),s("a",q,[n("单例模式"),e(a)]),n("来实现。")])]),S])}const G=o(l,[["render",z],["__file","抽象工厂.html.vue"]]),V=JSON.parse('{"path":"/guide/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html","title":"抽象工厂模式","lang":"zh-CN","frontmatter":{"title":"抽象工厂模式","description":"简介 抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。 抽象工厂模式抽象工厂模式 问题 假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示： 一系列相关产品， 例如 椅子Chair 、 沙发Sofa和 咖啡桌Coffee­Table 。 系列产品的不同变体。 例如， 你可以使用 现代Modern 、...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/guide/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.html"}],["meta",{"property":"og:site_name","content":"疼了也不哭"}],["meta",{"property":"og:title","content":"抽象工厂模式"}],["meta",{"property":"og:description","content":"简介 抽象工厂模式是一种创建型设计模式， 它能创建一系列相关的对象， 而无需指定其具体类。 抽象工厂模式抽象工厂模式 问题 假设你正在开发一款家具商店模拟器。 你的代码中包括一些类， 用于表示： 一系列相关产品， 例如 椅子Chair 、 沙发Sofa和 咖啡桌Coffee­Table 。 系列产品的不同变体。 例如， 你可以使用 现代Modern 、..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261655870.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"抽象工厂模式\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261655870.png\\",\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261655428.png\\",\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261656760.png\\",\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261721986.png\\",\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261722474.png\\",\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261722796.png\\",\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261722986.png\\",\\"https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/202404261723707.png\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[]},{"level":2,"title":"解决方案","slug":"解决方案","link":"#解决方案","children":[]},{"level":2,"title":"抽象工厂模式结构","slug":"抽象工厂模式结构","link":"#抽象工厂模式结构","children":[]},{"level":2,"title":"伪代码","slug":"伪代码","link":"#伪代码","children":[]},{"level":2,"title":"抽象工厂模式适合应用场景","slug":"抽象工厂模式适合应用场景","link":"#抽象工厂模式适合应用场景","children":[]},{"level":2,"title":"实现方式","slug":"实现方式","link":"#实现方式","children":[]},{"level":2,"title":"抽象工厂模式优缺点","slug":"抽象工厂模式优缺点","link":"#抽象工厂模式优缺点","children":[]},{"level":2,"title":"与其他模式的关系","slug":"与其他模式的关系","link":"#与其他模式的关系","children":[]}],"git":{},"readingTime":{"minutes":10.87,"words":3261},"filePathRelative":"guide/设计模式/创建型模式/抽象工厂.md","autoDesc":true}');export{G as comp,V as data};
