import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as d,c as a,e as n,d as t}from"./app-D1py-eEI.js";const o={},l=t(`<p>文章原文：https://gaoyubo.cn/blogs/844dc0e7.html</p><h1 id="一、class类文件的结构" tabindex="-1"><a class="header-anchor" href="#一、class类文件的结构"><span>一、Class类文件的结构</span></a></h1><blockquote><p>任何一个Class文件都对应着唯一的一个类或接口的定义信息。</p><p>但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。</p></blockquote><p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件中，中间没有任何分隔符。</p><p>Java 虚拟机规范规定 Class 文件采用一种类似 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数</strong>和<strong>表</strong>。</p><ul><li><strong>无符号数：</strong> 无符号数属于基本数据类型，以 u1、u2、u4、u8 分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，可以用它来描述数字、索引引用、数量值或 utf-8 编码的字符串值。</li><li><strong>表：</strong> 表是由多个无符号数或其他表为数据项构成的复合数据类型，名称上都以 <code>_info</code> 结尾。</li></ul><p>整个Class文件本质上也可以视作是一张表，这张表由数据项按严格顺序排列构成</p><table><thead><tr><th>英文名称</th><th>中文名称</th><th>类型</th><th>数量</th></tr></thead><tbody><tr><td>magic</td><td>魔数</td><td>u4</td><td>1</td></tr><tr><td>minor_version</td><td>次版本号</td><td>u2</td><td>1</td></tr><tr><td>major_version</td><td>主版本号</td><td>u2</td><td>1</td></tr><tr><td>constant_pool_count</td><td>常量池计数</td><td>u2</td><td>1</td></tr><tr><td>constant_pool</td><td>常量池</td><td>cp_info</td><td>constant_pool_count - 1</td></tr><tr><td>access_flags</td><td>访问标志</td><td>u2</td><td>1</td></tr><tr><td>this_class</td><td>类索引</td><td>u2</td><td>1</td></tr><tr><td>super_class</td><td>父类索引</td><td>u2</td><td>1</td></tr><tr><td>interfaces_count</td><td>接口计数</td><td>u2</td><td>1</td></tr><tr><td>interfaces</td><td>接口索引集合</td><td>u2</td><td>interfaces_count</td></tr><tr><td>fields_count</td><td>字段计数</td><td>u2</td><td>1</td></tr><tr><td>fields</td><td>字段表集合</td><td>field_info</td><td>fields_count</td></tr><tr><td>methods_count</td><td>方法计数</td><td>u2</td><td>1</td></tr><tr><td>methods</td><td>方法表集合</td><td>method_info</td><td>methods_count</td></tr><tr><td>attributes_count</td><td>属性计数</td><td>u2</td><td>1</td></tr><tr><td>attributes</td><td>属性集合</td><td>attribute_info</td><td>attributes_count</td></tr></tbody></table><p>其中，<code>cp_info</code> 、<code>field_info</code>、<code>method_info</code> 和 <code>attribute_info</code> 是更具体的结构，包含了常量池项、字段信息、方法信息和属性信息的详细描述。</p><blockquote><p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集 合”。</p></blockquote><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h2><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">algorithmAnalysis</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JVMTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;gaoyubo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/647621c2b09c2f2b1a095aa462ab0eef.png" alt="image-20231114235821239" style="zoom:50%;"><h2 id="_1-1魔数与版本号" tabindex="-1"><a class="header-anchor" href="#_1-1魔数与版本号"><span>1.1魔数与版本号</span></a></h2><p>Class 文件的头 8 个字节是魔数和版本号，其中头 4 个字节是魔数，也就是 <code>0xCAFEBABE</code>，它可以用来确定这个文件是否为一个能被虚拟机接受的 Class 文件（这通过扩展名来识别文件类型要安全，毕竟扩展名是可以随便修改的）。</p><p>后 4 个字节则是当前 Class 文件的版本号，其中第 5、6 个字节是次版本号，第 7、8 个字节是主版本号。</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/7859e1fee43971de686df3f44891c1ab.png" alt="image-20231114213923343" style="zoom:80%;"><h2 id="_1-2常量池" tabindex="-1"><a class="header-anchor" href="#_1-2常量池"><span>1.2常量池</span></a></h2><p>从第 9 个字节开始，就是常量池的入口，常量池是 Class 文件中：</p><ul><li>与其他项目关联最多的的数据类型；</li><li>占用 Class 文件空间最大的数据项目；</li><li>Class 文件中第一个出现的表类型数据项目。</li></ul><p>常量池的前两个字节，即第 9、10 个字节，存放着一个 u2 类型的数据，用于表示常量池中的常量数量 <code>cpc</code>（constant_pool_count）。</p><blockquote><p>这个计数值有一个特殊之处，即<strong>它是从 1 开始而不是从 0 开始的</strong>。 举例而言，如果 <code>cpc = 22</code>，那么说明常量池中包含 21 个常量，它们的索引值为 1 到 21。 第 0 项常量被保留为空，以便在某些情况下表示“不引用任何常量池项目”，此时将索引值设为 0 即可。</p></blockquote><p>常量池中记录主要包括以下两大类常量：</p><ul><li><strong>字面量：</strong> 接近于 Java 语言层面的常量概念 <ul><li>文本字符串</li><li>声明为 final 的常量值</li></ul></li><li><strong>符号引用</strong>：以一组符号来描述所引用的目标 <ul><li>被模块导出或开放的包（Package）</li><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li><li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li><li>动态调用点动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li></ul></li></ul><table><thead><tr><th>常量类型</th><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>CONSTANT_Utf8_info</td><td>1</td><td>UTF-8 编码的字符串</td></tr><tr><td>CONSTANT_Integer_info</td><td>3</td><td>整型字面量</td></tr><tr><td>CONSTANT_Float_info</td><td>4</td><td>浮点型字面量</td></tr><tr><td>CONSTANT_Long_info</td><td>5</td><td>长整型字面量</td></tr><tr><td>CONSTANT_Double_info</td><td>6</td><td>双精度浮点型字面量</td></tr><tr><td>CONSTANT_Class_info</td><td>7</td><td>类或接口的符号引用</td></tr><tr><td>CONSTANT_String_info</td><td>8</td><td>字符串字面量</td></tr><tr><td>CONSTANT_Fieldref_info</td><td>9</td><td>字段的符号引用</td></tr><tr><td>CONSTANT_Methodref_info</td><td>10</td><td>类或接口方法的符号引用</td></tr><tr><td>CONSTANT_InterfaceMethodref_info</td><td>11</td><td>接口方法的符号引用</td></tr><tr><td>CONSTANT_NameAndType_info</td><td>12</td><td>字段或方法的名称和描述符</td></tr><tr><td>CONSTANT_MethodHandle_info</td><td>15</td><td>方法句柄</td></tr><tr><td>CONSTANT_MethodType_info</td><td>16</td><td>方法类型</td></tr><tr><td>CONSTANT_Dynamic_info</td><td>17</td><td>动态计数常量</td></tr><tr><td>CONSTANT_InvokeDynamic_info</td><td>18</td><td>动态方法调用点</td></tr><tr><td>CONSTANT_Module_info</td><td>19</td><td>模块信息</td></tr><tr><td>CONSTANT_Package_info</td><td>20</td><td>包信息</td></tr></tbody></table><h4 id="constant-class-info" tabindex="-1"><a class="header-anchor" href="#constant-class-info"><span>CONSTANT_Class_info</span></a></h4><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span> tag<span class="token operator">=</span><span class="token number">7</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> name_index <span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span>  <span class="token number">1</span>位  <span class="token punctuation">]</span> <span class="token punctuation">[</span>     <span class="token number">2</span>位    <span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>tag 是标志位，用来区分常量类型的，tag = 7 就表示接下来的这个表是一个 CONSTANT_Class_info。</li><li>name_index 是一个索引值，指向常量池中的一个 CONSTANT_Utf8_info 类型的常量所在的索引值，CONSTANT_Utf8_info 类型常量一般被用来描述类的全限定名、方法名和字段名。它的存储结构如下：</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span> tag<span class="token operator">=</span><span class="token number">1</span> <span class="token punctuation">]</span> <span class="token punctuation">[</span> 当前常量的长度 len <span class="token punctuation">]</span> <span class="token punctuation">[</span> 常量的符号引用的字符串值 <span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">[</span>  <span class="token number">1</span>位  <span class="token punctuation">]</span> <span class="token punctuation">[</span>        <span class="token number">2</span>位        <span class="token punctuation">]</span> <span class="token punctuation">[</span>         len位         <span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="constant-fieldref-info" tabindex="-1"><a class="header-anchor" href="#constant-fieldref-info"><span>CONSTANT_Fieldref_info</span></a></h4><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">名称</th><th style="text-align:left;">数量</th></tr></thead><tbody><tr><td style="text-align:left;">ul</td><td style="text-align:left;">tag</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">u2</td><td style="text-align:left;">class_index</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">u2</td><td style="text-align:left;">name_and_type_index</td><td style="text-align:left;">1</td></tr></tbody></table><ul><li>tag: 表示标签，值为CONSTANT_Fieldref（9）。</li><li>class_index: 是一个指向CONSTANT_Class_info表的索引，该表中存储了字段所属的类或接口。</li><li>name_and_type_index: 是一个指向CONSTANT_NameAndType_info表的索引，该表中存储了字段的名称和描述符。</li></ul><h4 id="constant-method-ref-into" tabindex="-1"><a class="header-anchor" href="#constant-method-ref-into"><span>CONSTANT_Method ref_into</span></a></h4><p>以下是对固定长度的CONSTANT_Methodref_info表使用符号引用来表示类中声明的方法（不包括接口中的方法）进行优化和润色后的描述：固定长度的CONSTANT_Methodref_info表使用符号引用来表示类中声明的方法（不包括接口中的方法）。</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">名称</th><th style="text-align:left;">数量</th></tr></thead><tbody><tr><td style="text-align:left;">ul</td><td style="text-align:left;">tag</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">u2</td><td style="text-align:left;">class_index</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">u2</td><td style="text-align:left;">name_and_type_index</td><td style="text-align:left;">1</td></tr></tbody></table><ul><li><p>tag（标签）：tag项的值为CONSTANT_Methodref (10)。</p></li><li><p>class_index（类索引）：class_index项给出了声明了被引用方法的类的CONSTANT_Class_info表的索引。class_index所指定的CONSTANT_Class_info表必须表示一个类，而不能是接口。指向接口中声明的方法的符号引用应使用CONSTANT_InterfaceMethodref表。</p></li><li><p>name_and_type_index（名称和类型索引）：name_and_type_index提供了CONSTANT_NameAndType_info表的索引，该表提供了方法的简单名称和描述符。如果方法的简单名称以&quot;&lt;&quot;（\\u003c）符号开头，则该方法必须是一个实例化方法。它的简单名称应为&quot;&quot;，并且返回类型必须为void。否则，该方法应该是一个常规方法。</p></li></ul><h4 id="constant-string-info" tabindex="-1"><a class="header-anchor" href="#constant-string-info"><span>CONSTANT_String_info</span></a></h4><p>尚定长度的CONSTANT_String_info表用于存储文字字符串值，这些值可以表示为java.lang.String类的实例。该表仅存储文字字符串值，不存储符号引用。</p><table><thead><tr><th style="text-align:left;">类型</th><th style="text-align:left;">名称</th><th style="text-align:left;">数量</th></tr></thead><tbody><tr><td style="text-align:left;">ul</td><td style="text-align:left;">tag</td><td style="text-align:left;">1</td></tr><tr><td style="text-align:left;">u2</td><td style="text-align:left;">string_index</td><td style="text-align:left;">1</td></tr></tbody></table><ul><li>tag: 表示标签，值为CONSTANT_String（8）。</li><li>string_index: 是一个指向CONSTANT_Utf8_info表的索引，该表中存储了实际的字符串值。通过使用这样的表形式，可以方便地存储和引用字符串值，保证了程序的灵活性和可读性。</li></ul><p>如果全部介绍，篇幅太长，这里使用IDEA的<code>jclasslib</code>插件，查看效果如下：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/1dd574ed31d84b8ed275b2760706b383.png" alt="image-20231114235903061" style="zoom:50%;"><p>常量表中常量项定义如下：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/89b08b090ecaebd628f800eb47e284e6.png" alt="jvm-constPool1" style="zoom:50%;"><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/c126ab3a53937d613e6407c11f032bfd.png" alt="jvm-constPool2" style="zoom:80%;"><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/867b43ebfc2d8aa4847ce0bb5bf12722.png" alt="jvm-constPool3" style="zoom:80%;"><h2 id="_1-3访问标志" tabindex="-1"><a class="header-anchor" href="#_1-3访问标志"><span>1.3访问标志</span></a></h2><p>在常量池结束之后，紧接着的2个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：</p><p>这个Class是类还是接口？</p><ul><li>接口： <ul><li>是否定义为public类型；</li><li>是否定义为abstract类型；</li></ul></li><li>类： <ul><li>是否被声明为final；</li></ul></li></ul><p>以下为访问标志定义：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>类或接口是公共的</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>类不能被继承；方法不能被重写</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>当用 <code>invokespecial</code> 指令调用超类构造方法时，要求对该方法的调用使用 <code>super</code> 关键字</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标记接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>类没有实现所有的接口方法</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标记为由编译器生成的类或方法</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标记为注解类型</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标记为枚举类型</td></tr><tr><td>ACC_MODULE</td><td>0x8000</td><td>标记为模块</td></tr></tbody></table><p>访问标识通常是通过按位或运算符（<code>|</code>）进行计算的。每个访问标识都对应一个二进制位，通过将需要的标识的二进制位进行按位或运算，可以组合多个标识。</p><blockquote><p>上文的JVMTest.java：它的访问标识应该是 <code>ACC_PUBLIC</code> 和 <code>ACC_SUPER</code>。以下是分析：</p><ol><li><code>ACC_PUBLIC</code>（0x0001）: 这个标志表示类是公共的，可以从其他包访问。</li><li><code>ACC_SUPER</code>（0x0020）: 在 Java 5 之前，这个标志是为了向后兼容，当使用 <code>invokespecial</code> 指令调用超类构造方法时，要求对该方法的调用使用 <code>super</code> 关键字。</li></ol><p>因此，<code>JVMTest</code> 类的访问标识应该是 <code>ACC_PUBLIC | ACC_SUPER</code>，即 0x0021。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/bdb1c238e0c6c4693345796de7ea4bed.png" alt="image-20231115000052594" style="zoom:67%;"><h2 id="_1-4类索引、父类索引与接口索引" tabindex="-1"><a class="header-anchor" href="#_1-4类索引、父类索引与接口索引"><span>1.4类索引、父类索引与接口索引</span></a></h2><h3 id="类索引-this-class-和父类索引-super-class" tabindex="-1"><a class="header-anchor" href="#类索引-this-class-和父类索引-super-class"><span>类索引（this_class）和父类索引（super_class）</span></a></h3><ul><li><strong>类型：</strong><ul><li><code>this_class</code> 和 <code>super_class</code> 都是 <code>u2</code> 类型的数据。</li></ul></li><li><strong>作用：</strong><ul><li><code>this_class</code> 用于确定这个类的全限定名。</li><li><code>super_class</code> 用于确定这个类的父类的全限定名。</li></ul></li><li><strong>继承关系：</strong><ul><li>由于 Java 不允许多重继承，父类索引只有一个。</li><li>除了 <code>java.lang.Object</code> 之外，所有 Java 类都有父类。</li><li><strong>所以，除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></li></ul></li><li><strong>索引值：</strong><ul><li>类索引（<code>this_class</code>）和父类索引（<code>super_class</code>）分别用两个 <code>u2</code> 类型的索引值表示。</li><li>这两个索引值分别指向一个类型为 <code>CONSTANT_Class_info</code> 的类描述符常量。</li></ul></li><li><strong>全限定名查找：</strong><ul><li>通过 <code>CONSTANT_Class_info</code> 类型的常量中的索引值，可以找到定义在 <code>CONSTANT_Utf8_info</code> 类型的常量中的全限定名字符串。</li></ul></li></ul><h3 id="接口索引集合-interfaces" tabindex="-1"><a class="header-anchor" href="#接口索引集合-interfaces"><span>接口索引集合（interfaces）</span></a></h3><ul><li><strong>类型：</strong><ul><li><code>interfaces</code> 是一组 <code>u2</code> 类型的数据的集合。</li></ul></li><li><strong>作用：</strong><ul><li>用于描述这个类实现了哪些接口。</li></ul></li><li><strong>排列顺序：</strong><ul><li>接口索引集合中的接口将按 <code>implements</code> 关键字后的接口顺序从左到右排列。</li></ul></li><li><strong>注意事项：</strong><ul><li>如果这个 Class 文件表示的是一个接口，则应当使用 <code>extends</code> 关键字。</li></ul></li></ul><p>通过这三项数据，可以建立起类的继承关系和接口实现关系，确定类的层次结构和实现的接口，如下为全限定名索引查找过程。</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/bd6360e10afb8dfc608b244c0b5e72e7.png" alt="image-20231114230035312" style="zoom:50%;"><h3 id="class文件中示例" tabindex="-1"><a class="header-anchor" href="#class文件中示例"><span>class文件中示例</span></a></h3><p>访问标志后面紧跟类索引、父类索引、接口索引，JVMTest.class中表示如下，这里类索引u2值为0x0005，父类索引u2值为0x0006：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/781a2d1b74d17f010c195f89bc1ab576.png" alt="image-20231115000304683" style="zoom:50%;"><p>使用jclasslib查看u2值对应常量如下，可以看出JVMTest类的父类为Object类： <img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/07a591ee39a51870e3301902c31c1acb.png" alt="image-20231115000334908" style="zoom:50%;"></p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/51bf6773030b15e97b3b84e7ea53e8f8.png" alt="image-20231115000350477" style="zoom:50%;"><h2 id="_1-5字段表集合" tabindex="-1"><a class="header-anchor" href="#_1-5字段表集合"><span>1.5字段表集合</span></a></h2><ul><li><strong>描述：</strong><ul><li><code>field_info</code> 用于描述接口或类中声明的字段（变量）。</li><li>字段包括类级变量和实例级变量，但不包括在方法内部声明的局部变量。</li></ul></li><li><strong>字段信息包含的修饰符：</strong><ul><li><strong>作用域修饰符：</strong> 可以是 <code>public</code>、<code>private</code>、<code>protected</code>。</li><li><strong>变量类型修饰符：</strong> 区分实例变量和类变量，使用 <code>static</code> 修饰符。</li><li><strong>可变性修饰符：</strong> 使用 <code>final</code> 修饰符。</li><li><strong>并发可见性修饰符：</strong> 使用 <code>volatile</code> 修饰符，表示是否强制从主内存读写。</li><li><strong>序列化修饰符：</strong> 使用 <code>transient</code> 修饰符，表示是否可被序列化。</li></ul></li><li><strong>字段数据类型：</strong><ul><li>包括基本类型、对象和数组等。</li><li>数据类型不固定，通过引用常量池中的常量来描述。</li></ul></li><li><strong>字段名称：</strong><ul><li>字段名称不固定，通过引用常量池中的常量来描述。</li></ul></li><li><strong>修饰符的表示：</strong><ul><li>修饰符都是布尔值，要么存在某个修饰符，要么不存在。</li><li>使用标志位来表示修饰符的存在与否，以便紧凑地表示多个修饰符。</li></ul></li></ul><p>通过 <code>field_info</code>，可以详细描述字段的各种属性和特征，为 Java 类或接口的字段提供了灵活而精确的定义。</p><p>因此字段表结构定义如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th><th>数量</th></tr></thead><tbody><tr><td>access_flags</td><td>u2</td><td>访问标志</td><td>1</td></tr><tr><td>name_index</td><td>u2</td><td>字段名索引</td><td>1</td></tr><tr><td>descriptor_index</td><td>u2</td><td>描述符索引</td><td>1</td></tr><tr><td>attributes_count</td><td>u2</td><td>属性计数</td><td>1</td></tr><tr><td>attributes</td><td>attribute_info</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><h4 id="字段表访问标志-access-flags" tabindex="-1"><a class="header-anchor" href="#字段表访问标志-access-flags"><span>字段表访问标志（access_flags）</span></a></h4><p>其中，<code>access_flags</code>字段访问标志定义如下：</p><table><thead><tr><th>名称</th><th>标志值</th><th>描述</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>公共访问标志</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>私有访问标志</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>受保护访问标志</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>静态字段标志</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>常量字段标志</td></tr><tr><td>ACC_VOLATILE</td><td>0x0040</td><td>可变字段标志（并发可见性）</td></tr><tr><td>ACC_TRANSIENT</td><td>0x0080</td><td>短暂字段标志（不可序列化）</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>由编译器自动产生的标志</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>枚举类型字段标志</td></tr></tbody></table><h3 id="简单描述和描述符-name-index和descriptor-index" tabindex="-1"><a class="header-anchor" href="#简单描述和描述符-name-index和descriptor-index"><span>简单描述和描述符（name_index和descriptor_index）</span></a></h3><p>跟随access_flags标志的是两项索引值：name_index和descriptor_index。</p><ul><li>这两个索引值紧随 <code>access_flags</code> 标志之后，分别引用常量池中的项。</li><li><code>name_index</code> 代表字段的简单名称，指向常量池中的字符串项。</li><li><code>descriptor_index</code> 代表字段和方法的描述符，同样指向常量池中的字符串项。</li></ul><blockquote><ul><li><p><strong>全限定名：</strong> 类似于 <code>org/fenixsoft/clazz/TestClass</code>，是类的完整名称，将包名中的 <code>.</code> 替换为 <code>/</code>。为了在使用时避免混淆，通常在最后加入一个分号 <code>;</code> 表示全限定名结束。</p></li><li><p><strong>简单名称：</strong> 指没有类型和参数修饰的方法或字段名称。例如，<code>inc</code> 和 <code>m</code> 是 <code>inc()</code> 方法和 <code>m</code> 字段的简单名称。</p></li><li><p><strong>描述符：</strong></p><ul><li>描述符用于描述字段的数据类型、方法的参数列表（包括数量、类型和顺序）以及返回值。</li><li>基本数据类型（<code>byte</code>、<code>char</code>、<code>double</code>、<code>float</code>、<code>int</code>、<code>long</code>、<code>short</code>、<code>boolean</code>）以及代表无返回值的 <code>void</code> 类型都用一个大写字符表示。</li><li>对象类型则用字符 <code>L</code> 加对象的全限定名表示。</li></ul></li></ul></blockquote><p>如下为描述符的定义</p><table><thead><tr><th>标识字符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>byte</td></tr><tr><td>C</td><td>char</td></tr><tr><td>D</td><td>double</td></tr><tr><td>F</td><td>float</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long</td></tr><tr><td>S</td><td>short</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>V</td><td>void</td></tr><tr><td>L</td><td>对象类型（类或接口），如<code>Ljava/lang/Object</code></td></tr><tr><td>[</td><td>数组类型，可以嵌套，<code>java.lang.String[][]</code>类型的二维数组将被记录成<code>[[Ljava/lang/String</code><br>一个整型数组<code>int[]</code>将被记录成<code>[I</code></td></tr></tbody></table><p>方法描述符按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号 <code>()</code> 之内。</p><ul><li><p><strong>无参数、无返回值的方法（如 <code>void inc()</code>）：</strong></p><ul><li>描述符为 <code>()V</code>。</li></ul></li><li><p><strong>有返回值的方法（如 <code>java.lang.String toString()</code>）：</strong></p><ul><li>描述符为 <code>()Ljava/lang/String;</code>。</li><li>参数列表为空，返回值为对象类型（<code>Ljava/lang/String;</code>）。</li></ul></li><li><p><strong>有多个参数和返回值的方法（如 <code>int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex)</code>）：</strong></p><ul><li>描述符为 <code>([CII[CIII)I</code>。</li><li>参数列表： <ul><li><code>([C</code>：char 数组类型</li><li><code>II</code>：两个 int 类型</li><li><code>[C</code>：另一个 char 数组类型</li><li><code>III</code>：三个 int 类型</li></ul></li><li>返回值：<code>I</code> 表示 int 类型。</li></ul></li></ul><h3 id="属性表" tabindex="-1"><a class="header-anchor" href="#属性表"><span>属性表</span></a></h3><p>字段表中的固定数据项一直到 <code>descriptor_index</code> 为止，而在 <code>descriptor_index</code> 之后，跟随着一个属性表集合。这个属性表集合用于存储一些额外的信息，允许字段表附加描述零至多项的额外信息。</p><ol><li><strong>属性表计数器：</strong><ul><li>用于记录附加到字段上的属性个数。</li><li>计数器的值决定了接下来有多少个属性项。</li></ul></li><li><strong>属性表中可能的额外信息：</strong><ul><li>ConstantValue 属性： <ul><li>如果字段被声明为 <code>final static int m = 123;</code>，则可能存在一项名称为 <code>ConstantValue</code> 的属性。</li><li>这个属性的值指向常量 123。</li></ul></li></ul></li><li><strong>其他属性项：</strong><ul><li>根据字段的具体声明，可能存在其他类型的属性，如访问控制等。</li></ul></li></ol><p>通过属性表集合，字段表可以携带额外的信息，例如常量值、访问控制等，以满足不同字段的需求。在本例中，由于字段 <code>m</code> 的声明为 <code>final static int m = 123;</code>，因此可能包含 <code>ConstantValue</code> 属性，指向常量 123。</p><h3 id="字段表集合的特性" tabindex="-1"><a class="header-anchor" href="#字段表集合的特性"><span>字段表集合的特性</span></a></h3><ol><li><strong>不包含从父类或父接口中继承的字段：</strong><ul><li>字段表集合中不会列出从父类或者父接口中继承而来的字段。</li><li>继承的字段在子类的字段表中不会重复出现，因为已经在父类的字段表中定义。</li></ul></li><li><strong>可能包含编译器生成的字段：</strong><ul><li>在某些情况下，编译器会自动添加一些字段，例如在内部类中为了保持对外部类的访问性，可能会自动添加指向外部类实例的字段。</li></ul></li><li><strong>字段重名的合法性：</strong><ul><li>在 Java 语言中，字段是无法重载的，即两个字段的数据类型、修饰符不管是否相同，都必须使用不同的名称。</li><li>但在 Class 文件格式中，只要两个字段的描述符不是完全相同，字段重名是合法的。描述符不同即使字段名称相同也是合法的。</li></ul></li></ol><h3 id="class文件中示例-1" tabindex="-1"><a class="header-anchor" href="#class文件中示例-1"><span>class文件中示例</span></a></h3><p>在class文件中，表示如下，按照顺序分别是fields_count，access_flags，name_index，descriptor_index：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/91f4bc58169a7aaa93a2fc089bd8c8d8.png" alt="image-20231115000631384" style="zoom:67%;"><p>0x0001：说明这个类只有一个字段表数据</p><p>0x0002：代表private修饰符的ACC_PRIVATE 标志位为真（ACC_PRIVATE标志的值为0x0002）</p><p>0x0008：字面量为<code>m</code>，在常量池中对应内容如下图 <img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/943c9e95d3ee0a6a7d6ac3e30452d3e2.png" alt="image-20231115001408220" style="zoom:50%;"></p><p>0x0009：字面量<code>I</code>，在常量池中对应内容如下图</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/be7e756bcfdf9e903fe00458c1265475.png" alt="image-20231115001454132" style="zoom:50%;"><blockquote><p>与类访问标志相同，字段访问标志计算字段访问标志的值也是通过按位或（<code>|</code>）操作将各个标志的值组合而成的。</p><p>例如，如果一个字段是 <code>public</code> 和 <code>static</code> 的，那么其访问标志的值为 <code>ACC_PUBLIC | ACC_STATIC</code></p><p>如果有两个字段，那么这个顺序就会重复两次，依次表示两个字段的描述信息。</p></blockquote><h2 id="_1-6方法表集合" tabindex="-1"><a class="header-anchor" href="#_1-6方法表集合"><span>1.6方法表集合</span></a></h2><p>Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样。</p><p>依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项</p><p>因此方法表表结构定义如下：</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th><th>数量</th></tr></thead><tbody><tr><td>access_flags</td><td>u2</td><td>访问标志</td><td>1</td></tr><tr><td>name_index</td><td>u2</td><td>方法名索引</td><td>1</td></tr><tr><td>descriptor_index</td><td>u2</td><td>描述符索引</td><td>1</td></tr><tr><td>attributes_count</td><td>u2</td><td>属性计数</td><td>1</td></tr><tr><td>attributes</td><td>attribute_info</td><td>属性集合</td><td>attributes_count</td></tr></tbody></table><blockquote><p>方法的定义可以通过访问标志、名称索引、描述符索引来表达清楚，但方法内部的Java代码去哪里了？</p><p>方法内的Java代码在经过Javac编译器编译成字节码指令后，实际上存放在方法属性表集合中的一个名为“Code”的属性里面。属性表作为Class文件格式中最具扩展性的一种数据项目，将在后续介绍。</p></blockquote><h3 id="方法表的访问标志" tabindex="-1"><a class="header-anchor" href="#方法表的访问标志"><span>方法表的访问标志</span></a></h3><p>方法表的访问标志中不包含 <code>ACC_VOLATILE</code> 和 <code>ACC_TRANSIENT</code> 标志，因为 <code>volatile</code> 和 <code>transient</code> 关键字不能修饰方法。</p><p>相反，方法表的访问标志中增加了以下标志，因为这些关键字可以修饰方法：</p><ul><li><code>ACC_SYNCHRONIZED</code>：用于修饰同步方法，表示该方法是同步方法。</li><li><code>ACC_NATIVE</code>：表示该方法用其他语言（如 C）实现，由本地方法库提供。</li><li><code>ACC_STRICTFP</code>：表示该方法遵循 IEEE 754 浮点运算规范。</li><li><code>ACC_ABSTRACT</code>：表示该方法是抽象方法，没有具体的实现。</li></ul><p>以下是方法表的访问标志及其取值：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>描述</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>公共访问标志</td></tr><tr><td>ACC_PRIVATE</td><td>0x0002</td><td>私有访问标志</td></tr><tr><td>ACC_PROTECTED</td><td>0x0004</td><td>受保护访问标志</td></tr><tr><td>ACC_STATIC</td><td>0x0008</td><td>静态方法标志</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>常量方法标志</td></tr><tr><td>ACC_SYNCHRONIZED</td><td>0x0020</td><td>同步方法标志</td></tr><tr><td>ACC_BRIDGE</td><td>0x0040</td><td>桥接方法标志</td></tr><tr><td>ACC_VARARGS</td><td>0x0080</td><td>可变参数方法标志</td></tr><tr><td>ACC_NATIVE</td><td>0x0100</td><td>本地方法标志</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>抽象方法标志</td></tr><tr><td>ACC_STRICTFP</td><td>0x0800</td><td>严格浮点标志</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>由编译器自动生成的标志</td></tr></tbody></table><h3 id="class文件中示例-2" tabindex="-1"><a class="header-anchor" href="#class文件中示例-2"><span>class文件中示例</span></a></h3><p>按照顺序分别为：<code>method_count</code>,<code>access_flags</code>,<code>name_index</code>,<code>descriptor_index</code>,<code>attributes_count</code>,<code>attribute_name_index</code></p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/41fda37bba40c7c287b4935b21d38d58.png" alt="image-20231115160405529" style="zoom:67%;"><p>0x0003（<code>method_count</code>）：说明这个类有三个方法，编译器自动添加了&lt;init&gt;方法，即实例构造器，如下： <img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/79dec29138829a170aa0c5d4b64e202a.png" alt="image-20231115160917202" style="zoom:50%;"></p><p>0x0001（<code>access_flags</code>）：只有ACC_PUBLIC标志为真</p><p>0x000A（<code>name_index</code>）：字面量索引位10：字面量为&lt;init&gt;</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/5546747b19afdb7de7567b6bd099ca86.png" alt="image-20231115161005373" style="zoom:50%;"><p>0x000B（<code>descriptor_index</code>）:字面量索引位11，字面量<code>()V</code>，代表void返回类型，参数列表为空</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/9d97d640a1252455bdf206c9ac0bfdb9.png" alt="image-20231115161133878" style="zoom:50%;"><p>0x0001(<code>attributes_count</code>)：表示此方法的属性表集合有1项属性</p><p>0x000C(<code>attribute_name_index</code>)：属性名称的索引值为0x000C，对应常量为“Code”</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/38b1c495a3a8e8df828268b663514551.png" alt="image-20231115161432171" style="zoom:50%;"><p>字段表集合相对应地，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出 现来自父类的方法信息。 但同样地，有可能会出现由编译器自动添加的方法，最常见的便是类构造器<code>&lt;clinit&gt;()</code>方法和实例构造器<code>&lt;init&gt;()</code>方法</p><blockquote><p>在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的<code>特征签名</code></p><p>(<strong>Java代码的方法特征签名只包括方法名称、参数顺序及参数类型</strong>，而字节码的特征签名还包括方法返回值以及受查异常表)。</p><p>由于返回值不包含在特征签名中，因此无法仅仅通过返回值的不同来对一个已有方法进行重载,如下图。</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/f952a5240da28dca41646ab80ee0f252.png" alt="image-20231115162548801" style="zoom:50%;"><p>然而，在Class文件格式中，特征签名的范围明显更大。只要两个方法的描述符不完全相同，它们就可以在同一个Class文件中合法共存。具体来说，如果两个方法具有相同的名称和特征签名，但返回值不同，它们仍然可以在同一个Class文件中存在。</p></blockquote><h2 id="_1-7属性表集合" tabindex="-1"><a class="header-anchor" href="#_1-7属性表集合"><span>1.7属性表集合</span></a></h2><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以 携带自己的属性表集合，以描述某些场景专有的信息。</p><p>在《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项，如下：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/801d4dd1dbb4fb69e72921746003ca1f.png" alt="image-20231116145829332" style="zoom:67%;"><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/fa8739c19ffc5cd0c86fe2a9a702cec8.png" alt="image-20231116145859903" style="zoom:67%;"><p>对于每一个属性，它的名称都要从常量池中引用一个<code>CONSTANT_Utf8_info</code>类型的常量来表示， 而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足下表结构。</p><table><thead><tr><th>名称</th><th>类型</th><th>数量</th></tr></thead><tbody><tr><td>attribute_name_index</td><td>u2</td><td>1</td></tr><tr><td>attribute_length</td><td>u4</td><td>1</td></tr><tr><td>info</td><td>u1</td><td>attribute_count</td></tr></tbody></table><h3 id="code属性" tabindex="-1"><a class="header-anchor" href="#code属性"><span>Code属性</span></a></h3><p>在Java程序中，方法体内的代码在经过Javac编译器处理之后，最终被转化为字节码指令，并存储在方法表的属性集合中的Code属性内。需要注意的是，并非所有的方法表都必须包含Code属性。例如，在接口或抽象类中的方法就不存在Code属性。</p><table><thead><tr><th>属性名称</th><th>类型</th><th>描述</th><th>数量</th></tr></thead><tbody><tr><td>attribute_name_index</td><td>u2</td><td>指向UTF-8常量的索引，表示属性名称(Code)</td><td>1</td></tr><tr><td>max_stack</td><td>u2</td><td>操作数栈的最大深度</td><td>1</td></tr><tr><td>max_locals</td><td>u2</td><td>局部变量表的最大容量</td><td>1</td></tr><tr><td>code_length</td><td>u4</td><td>字节码指令的长度</td><td>1</td></tr><tr><td>code</td><td>u1[code_length]</td><td>存储实际字节码指令的数组</td><td>code_length</td></tr><tr><td>exception_table_length</td><td>u2</td><td>异常处理表的长度</td><td>1</td></tr><tr><td>exception_table</td><td>exception_info</td><td>异常处理表</td><td>0或多</td></tr><tr><td>attributes_count</td><td>u2</td><td>Code属性的属性数量</td><td>1</td></tr><tr><td>attributes</td><td>attribute_info[attributes_count]</td><td>Code属性的属性集合</td><td>0或多</td></tr></tbody></table><ul><li><strong>max_stack：</strong> 操作数栈的最大深度，在方法执行的任意时刻，操作数栈都不会超过这个深度。</li><li><strong>max_locals：</strong> 局部变量表所需的存储空间，以变量槽为单位，变量槽是虚拟机为局部变量分配内存的最小单位。</li><li><strong>code_length：</strong> 字节码指令的长度，限制为不超过65535字节。</li><li><strong>code：</strong> 存储实际字节码指令的一系列字节流。</li><li><strong>exception_table_length：</strong> 异常处理表的长度，记录方法中的异常处理信息。</li><li><strong>exception_table：</strong> 异常处理表，包括起始字节码指令位置、结束字节码指令位置、异常处理程序入口位置和捕获异常的类索引。</li><li><strong>attributes_count：</strong> Code属性的属性数量，用于存储额外的属性信息。</li><li><strong>attributes：</strong> Code属性的属性集合，可能包含一些额外的信息，如调试信息等。</li></ul><h4 id="class文件中示例-3" tabindex="-1"><a class="header-anchor" href="#class文件中示例-3"><span>class文件中示例</span></a></h4><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/53b788641f81d868a5bfad51f8a2b097.png" alt="image-20231116155555581" style="zoom:67%;"><p>属性表的<code>attribute_name_index</code>后的<code>00 00 00 2F</code>表示属性值的长度。在这里，<code>00 00 00 2F</code>表示长度为47个字节。它告诉虚拟机在读取属性值时要读取47个字节的内容。如果前面的0x000C的字面量<code>Code</code>虚拟机不认识，那么就可以跳过这些长度。</p><blockquote><p>《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。</p></blockquote><p>按顺序分别为：max_stack，max_locals，code_length，code</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/fcbf087efe7ac98e3fb067fc46a06db7.png" alt="image-20231116160039741" style="zoom:67%;"><p>0x0001: 操作数栈的最大深度为1</p><p>0x0001: 本地变量表容量为1</p><p>0x00000005: 字节码区域 所占空间的长度为0x0005。虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并 根据字节码指令表翻译出所对应的字节码指令</p><p><strong>翻译“2A B7000A B1”的过程为：</strong></p><ol><li>读入 <code>2A</code>，查表得到 <code>aload_0</code> 指令，作用是将第 0 个变量槽中的 <code>reference</code> 类型的本地变量推送到操作数栈顶。</li><li>读入 <code>B7</code>，查表得到 <code>invokespecial</code> 指令，该指令以栈顶的 <code>reference</code> 类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、<code>private</code> 方法或者它的父类的方法。该方法有一个 <code>u2</code> 类型的参数，指向常量池中的一个 <code>CONSTANT_Methodref_info</code> 类型常量，即此方法的符号引用。</li><li>读入 <code>000A</code>，这是 <code>invokespecial</code> 指令的参数，代表一个符号引用。查常量池得到 <code>0x000A</code> 对应的常量，表示实例构造器 <code>&lt;init&gt;()</code> 方法的符号引用。</li><li>读入 <code>B1</code>，查表得到 <code>return</code> 指令，含义是从方法返回，并且返回值为 <code>void</code>。执行这条指令后，当前方法正常结束。</li></ol><blockquote><p>这里查的表是 Java 虚拟机规范中定义的字节码指令表。字节码指令表包含了每个操作码（opcode）对应的具体指令和操作。</p><p>部分其他指令如下：</p><table><thead><tr><th>指令</th><th>助记符</th><th>描述</th></tr></thead><tbody><tr><td>0x03</td><td>iconst_2</td><td>将整数常量值 2 推送到操作数栈顶</td></tr><tr><td>0x10</td><td>bipush</td><td>将一个字节推送到栈顶，作为整数使用</td></tr><tr><td>0x60</td><td>iadd</td><td>将栈顶两个整数相加</td></tr><tr><td>0x2D</td><td>fsub</td><td>将栈顶两个浮点数相减</td></tr><tr><td>0xC7</td><td>ifnonnull</td><td>如果引用不为 null，则跳转</td></tr></tbody></table></blockquote><h4 id="异常表" tabindex="-1"><a class="header-anchor" href="#异常表"><span>异常表</span></a></h4><p>在字节码指令之后的是这个方法的显式异常处理表（下文简称“异常表”）集合，异常表对于Code 属性来说并不是必须存在的。</p><p>异常表的格式如下：</p><table><thead><tr><th>字段名</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>start_pc</td><td>u2</td><td>起始字节码行号</td></tr><tr><td>end_pc</td><td>u2</td><td>结束字节码行号（不含）</td></tr><tr><td>handler_pc</td><td>u2</td><td>异常处理代码的字节码行号</td></tr><tr><td>catch_type</td><td>u2</td><td>指向一个CONSTANT_Class_info型常量的索引，表示捕获的异常类型。为0时表示捕获所有异常。</td></tr></tbody></table><p>演示：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">inc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后的字节码和异常表：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public int inc(); 
Code: 
  Stack=1, Locals=5, Args_size=1 
  0: iconst_1      // 将整数1推送到栈顶，try块中的x=1
  1: istore_1      // 将栈顶的值存储到本地变量表的变量槽1中
  2: iload_1       // 将本地变量表中的变量槽1的值推送到栈顶
  3: istore 4      // 将栈顶的值存储到本地变量表的变量槽4中
  5: iconst_3      // 将整数3推送到栈顶，finally块中的x=3
  6: istore_1      // 将栈顶的值存储到本地变量表的变量槽1中
  7: iload 4       // 将本地变量表中的变量槽4的值推送到栈顶
  9: ireturn       // 从方法返回，返回值为栈顶的值

10: astore_2       // 将栈顶的异常对象存储到本地变量表的变量槽2中
11: iconst_2       // 将整数2推送到栈顶，catch块中的x=2
12: istore_1       // 将栈顶的值存储到本地变量表的变量槽1中
13: iload_1        // 将本地变量表中的变量槽1的值推送到栈顶
14: istore 4       // 将栈顶的值存储到本地变量表的变量槽4中
16: iconst_3       // 将整数3推送到栈顶，finally块中的x=3
17: istore_1       // 将栈顶的值存储到本地变量表的变量槽1中
18: iload 4        // 将本地变量表中的变量槽4的值推送到栈顶
20: ireturn        // 从方法返回，返回值为栈顶的值

21: astore_3       // 将栈顶的异常对象存储到本地变量表的变量槽3中
22: iconst_3       // 将整数3推送到栈顶，finally块中的x=3
23: istore_1       // 将栈顶的值存储到本地变量表的变量槽1中
24: aload_3        // 将本地变量表中的变量槽3的值（异常对象）推送到栈顶
25: athrow         // 抛出栈顶的异常

Exception table: 
  from    to  target type
     0     0    10   Class java/lang/Exception
     5     5    16   any
    10    21    21   Class java/lang/Exception

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这段字节码中，前五行主要是try块的内容。首先，整数1被赋给变量x，然后通过<code>istore_1</code>指令将x的值保存在第一个本地变量槽（slot）中。接下来，将3推送到操作数栈，再通过<code>istore</code>指令将其存储在第四个本地变量槽中，这个槽被称为<code>returnValue</code>。</p><p>接下来的<code>iload_1</code>指令将第一个本地变量槽中的x值加载到操作数栈顶，然后通过<code>ireturn</code>指令返回这个值。因此，如果try块中没有异常，方法将返回1。</p><p>在异常情况下，程序将跳转到第10行（catch块）。异常处理块首先将2赋给变量x，然后通过<code>istore_1</code>指令将x的值保存在第一个本地变量槽中。接着，将之前保存在<code>returnValue</code>中的值（即1）加载到操作数栈顶，然后通过<code>ireturn</code>指令返回这个值。因此，如果发生异常，方法将返回2。</p><p>最后，无论是否发生异常，程序都会执行finally块（第21行开始）。在finally块中，将3赋给变量x，并使用<code>athrow</code>指令抛出之前发生的异常。虽然这里没有具体的异常类型，但finally块的主要目的是在方法返回前执行清理工作。</p><h3 id="exceptions属性" tabindex="-1"><a class="header-anchor" href="#exceptions属性"><span>Exceptions属性</span></a></h3><p>这里的Exceptions属性是在方法表中与Code属性平级的一项属性，不要与前面刚刚讲解完的异常表产生混淆。</p><p>Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法<strong>描述时在throws关键字后面列举</strong>的异常。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>attribute_name_index</td><td>u2</td><td>指向常量池中CONSTANT_Utf8_info类型的异常表属性名称的索引</td></tr><tr><td>attribute_length</td><td>u4</td><td>属性值的长度，不包括attribute_name_index和attribute_length自身的长度</td></tr><tr><td>number_of_exceptions</td><td>u2</td><td>异常表中的异常个数</td></tr><tr><td>exception_index_table</td><td>u2 数组</td><td>每个元素都是指向常量池中CONSTANT_Class_info类型的索引，表示受检异常的类型</td></tr></tbody></table><h3 id="linenumbertable-属性" tabindex="-1"><a class="header-anchor" href="#linenumbertable-属性"><span>LineNumberTable 属性</span></a></h3><p>LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。虽然它不是运行时必需的属性，但默认会生成到Class文件中。通过使用Javac中的-g：none或-g：lines选项，可以选择是否生成这项信息。如果选择不生成LineNumberTable属性，对程序运行的主要影响之一是在抛出异常时，堆栈跟踪中将不会显示出错的行号。此外，调试程序时也无法按照源码行来设置断点。</p><p>在调试和排查问题时，LineNumberTable属性是非常有用的，因为它建立了Java源代码和编译后的字节码之间的映射。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>attribute_name_index</td><td>u2</td><td>指向常量池中CONSTANT_Utf8_info类型的属性名称 &quot;LineNumberTable&quot; 的索引</td></tr><tr><td>attribute_length</td><td>u4</td><td>属性值的长度，不包括 attribute_name_index 和 attribute_length 自身的长度</td></tr><tr><td>line_number_table</td><td>表</td><td>包含多个行号项的表，每个行号项包括 start_pc 和 line_number 字段，表示字节码行号和源代码行号的映射关系</td></tr></tbody></table><h3 id="localvariabletable-属性" tabindex="-1"><a class="header-anchor" href="#localvariabletable-属性"><span>LocalVariableTable 属性</span></a></h3><p>LocalVariableTable属性用于描述栈帧中局部变量表的变量与Java源码中定义的变量之间的关系。虽然它不是运行时必需的属性，但默认会生成到Class文件中。可以使用Javac中的-g：none或-g：vars选项来选择是否生成这项信息。如果没有生成这项属性，最大的影响之一是当其他人引用这个方法时，所有的参数名称都将会丢失。例如，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名。这对程序运行没有影响，但会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获取参数值。</p><p>LocalVariableTable属性对于理解程序的执行过程以及在调试中获取更多有关局部变量的信息非常有用。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>attribute_name_index</td><td>u2</td><td>指向常量池中CONSTANT_Utf8_info类型的属性名称 &quot;LocalVariableTable&quot; 的索引</td></tr><tr><td>attribute_length</td><td>u4</td><td>属性值的长度，不包括 attribute_name_index 和 attribute_length 自身的长度</td></tr><tr><td>local_variable_table</td><td>表</td><td>包含多个局部变量项的表，每个局部变量项包括 start_pc、length、name_index、descriptor_index 和 index 字段，表示局部变量在字节码中的范围、名称、描述符和索引</td></tr></tbody></table><h3 id="sourcefile-属性" tabindex="-1"><a class="header-anchor" href="#sourcefile-属性"><span>SourceFile 属性</span></a></h3><p>SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性是可选的，可以使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在大多数情况下，Java类的类名和文件名是一致的，但是在一些特殊情况（例如内部类）下可能存在例外情况。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性。</p><p>ourceFile属性有助于在调试时追踪代码，特别是在涉及多个源文件的项目中。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>attribute_name_index</td><td>u2</td><td>指向常量池中CONSTANT_Utf8_info类型的属性名称 &quot;SourceFile&quot; 的索引</td></tr><tr><td>attribute_length</td><td>u4</td><td>属性值的长度，不包括 attribute_name_index 和 attribute_length 自身的长度</td></tr><tr><td>sourcefile_index</td><td>u2</td><td>指向常量池中CONSTANT_Utf8_info类型的源文件名的索引</td></tr></tbody></table><h3 id="sourcedebugextension-属性" tabindex="-1"><a class="header-anchor" href="#sourcedebugextension-属性"><span>SourceDebugExtension 属性</span></a></h3><p>SourceDebugExtension属性是为了存储额外的代码调试信息，特别是在涉及非Java语言编写、但需要编译成字节码并在Java虚拟机中运行的程序时。这个属性的数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，该常量的值是源代码文件的调试信息。</p><p>在JDK 5时，引入了SourceDebugExtension属性，用于存储JSR 45提案所定义的标准调试信息。这对于需要在Java虚拟机中运行的非Java语言编写的程序提供了一种标准的调试机制。典型的场景是在进行JSP文件调试时，由于无法通过Java堆栈来定位到JSP文件的行号，可以使用SourceDebugExtension属性来存储额外的调试信息，使程序员能够更快速地从异常堆栈中定位到原始JSP中出现问题的行号。</p><p>这个属性在一些特定的情况下很有用，但在一般的Java程序开发中，由于使用Java语言编写，通常不需要额外的非Java调试信息。因此，对于大多数Java应用，可能并不常见。</p><table><thead><tr><th>字段名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>attribute_name_index</td><td>u2</td><td>指向常量池中CONSTANT_Utf8_info类型的属性名称 &quot;SourceDebugExtension&quot; 的索引</td></tr><tr><td>attribute_length</td><td>u4</td><td>属性值的长度，不包括 attribute_name_index 和 attribute_length 自身的长度</td></tr><tr><td>debug_extension</td><td>字节数组</td><td>包含调试信息的字节数组</td></tr></tbody></table><p>还有很多属性如：不再赘述</p><ul><li><code>AnnotationDefault</code></li><li><code>BootstrapMethods</code></li><li><code>MethodParameters</code> ...</li></ul><h1 id="二、字节码指令" tabindex="-1"><a class="header-anchor" href="#二、字节码指令"><span>二、字节码指令</span></a></h1><p>在Java虚拟机的指令集中，指令可以分为多个大的类别，以下是其中一些主要的指令类别：</p><ol><li><strong>加载和存储指令（Load and Store Instructions）:</strong><ul><li><code>aaload</code>, <code>aastore</code>, <code>baload</code>, <code>bastore</code>, <code>caload</code>, <code>castore</code>, <code>daload</code>, <code>dastore</code>, <code>faload</code>, <code>fastore</code>, <code>iaload</code>, <code>iastore</code>, <code>laload</code>, <code>lastore</code>, <code>saload</code>, <code>sastore</code>, 等。</li></ul></li><li><strong>操作数栈管理指令（Stack Management Instructions）:</strong><ul><li><code>pop</code>, <code>pop2</code>, <code>dup</code>, <code>dup_x1</code>, <code>dup_x2</code>, <code>dup2</code>, <code>dup2_x1</code>, <code>dup2_x2</code>, <code>swap</code>, 等。</li></ul></li><li><strong>数学运算指令（Arithmetic Instructions）:</strong><ul><li><code>iadd</code>, <code>isub</code>, <code>imul</code>, <code>idiv</code>, <code>irem</code>, <code>iinc</code>, <code>ladd</code>, <code>lsub</code>, <code>lmul</code>, <code>ldiv</code>, <code>lrem</code>, <code>fadd</code>, <code>fsub</code>, <code>fmul</code>, <code>fdiv</code>, <code>frem</code>, <code>dadd</code>, <code>dsub</code>, <code>dmul</code>, <code>ddiv</code>, <code>drem</code>, 等。</li></ul></li><li><strong>类型转换指令（Type Conversion Instructions）:</strong><ul><li><code>i2l</code>, <code>i2f</code>, <code>i2d</code>, <code>l2i</code>, <code>l2f</code>, <code>l2d</code>, <code>f2i</code>, <code>f2l</code>, <code>f2d</code>, <code>d2i</code>, <code>d2l</code>, <code>d2f</code>, <code>i2b</code>, <code>i2c</code>, <code>i2s</code>, 等。</li></ul></li><li><strong>比较指令（Comparison Instructions）:</strong><ul><li><code>lcmp</code>, <code>fcmpl</code>, <code>fcmpg</code>, <code>dcmpl</code>, <code>dcmpg</code>, <code>ifcmp&lt;cond&gt;</code>, <code>&lt;cond&gt;</code>, <code>if&lt;cond&gt;</code>, 等。</li></ul></li><li><strong>控制转移指令（Control Transfer Instructions）:</strong><ul><li><code>goto</code>, <code>tableswitch</code>, <code>lookupswitch</code>, <code>ireturn</code>, <code>lreturn</code>, <code>freturn</code>, <code>dreturn</code>, <code>areturn</code>, <code>return</code>, <code>athrow</code>, <code>jsr</code>, <code>ret</code>, <code>if&lt;cond&gt;</code>, 等。</li></ul></li><li><strong>引用类和对象的指令（Reference Instructions）:</strong><ul><li><code>new</code>, <code>newarray</code>, <code>anewarray</code>, <code>multianewarray</code>, <code>checkcast</code>, <code>instanceof</code>, <code>getfield</code>, <code>putfield</code>, <code>getstatic</code>, <code>putstatic</code>, 等。</li></ul></li><li><strong>方法调用和返回指令（Method Invocation and Return Instructions）:</strong><ul><li><code>invokevirtual</code>, <code>invokespecial</code>, <code>invokestatic</code>, <code>invokeinterface</code>, <code>invokedynamic</code>, <code>return</code>, <code>areturn</code>, <code>ireturn</code>, <code>lreturn</code>, <code>freturn</code>, <code>dreturn</code>, 等。</li></ul></li><li><strong>异常处理指令（Exception Handling Instructions）:</strong><ul><li><code>athrow</code>, <code>monitorenter</code>, <code>monitorexit</code>, <code>try-catch-finally</code> 块相关的指令。</li></ul></li></ol><p>这些指令构成了Java虚拟机的指令集，用于执行Java字节码。每个指令都有特定的操作码和操作数，用于在操作数栈上执行相应的操作</p><p>字节码指令集在Java虚拟机中具有独特的特点和一些限制：</p><ol><li><strong>操作码长度限制：</strong> 指令集的操作码被限制为一个字节，范围为0～255，这意味着指令集的操作码总数不能超过256条。这种设计有助于简化指令的编码和解码过程。</li><li><strong>操作数长度对齐：</strong> Class文件格式中放弃了编译后代码的操作数长度对齐。这意味着虚拟机在处理超过一个字节的数据时，需要在运行时从字节中重建具体数据的结构。例如，将一个16位长度的无符号整数存储在两个无符号字节中，需要使用表达式 <code>(byte1 &lt;&lt; 8) | byte2</code> 进行重建。</li></ol><p>这些设计选择有一些优势和劣势：</p><p><strong>优势：</strong></p><ul><li><strong>紧凑性：</strong> 一个字节的操作码和简化的操作数对于Class文件的紧凑性是有利的，减小了字节码文件的大小。</li><li><strong>解析速度：</strong> 简单的指令格式和有限的操作码范围有助于提高字节码的解析速度。</li></ul><p><strong>劣势：</strong></p><ul><li><strong>指令数限制：</strong> 256条操作码的限制可能限制了指令集的丰富性，尽管在实践中这仍然足够支持丰富的语义。</li><li><strong>运行时处理成本：</strong> 虚拟机在处理较大的数据时需要进行运行时的计算，可能增加了一些运行时的成本。</li></ul><p>总体而言，这些设计选择是为了在保持紧凑性和解析速度的同时，提供足够的灵活性来支持Java虚拟机的执行需求。</p><p>如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模 型来理解，这个执行模型虽然很简单，但依然可以有效正确地工作</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>do { 
    自动计算PC寄存器的值加1; 
    根据PC寄存器指示的位置，从字节码流中取出操作码; 
    if (字节码存在操作数) 
    	从字节码流中取出操作数; 
    	执行操作码所定义的操作;
} while (字节码流长度 &gt; 0);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-1字节码与数据类型" tabindex="-1"><a class="header-anchor" href="#_2-1字节码与数据类型"><span>2.1字节码与数据类型</span></a></h2><p>如下列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。</p><p>如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。例如load指令有操作int类型的iload，但是没有操作byte类型的同类指令。</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/994661055c49c9e0920f1060f23a1027.png" alt="image-20231117183830521" style="zoom:80%;">`,200),s=t(`<p>具体而言：</p><ul><li><strong>带符号扩展（Sign-Extend）：</strong> 对于<code>byte</code>和<code>short</code>类型，编译器会进行带符号扩展，将它们转换为相应的<code>int</code>类型。这意味着，如果原始值是负数，它会被符号扩展为32位带符号整数。</li><li><strong>零位扩展（Zero-Extend）：</strong> 对于<code>boolean</code>和<code>char</code>类型，同样会进行零位扩展，将它们转换为相应的<code>int</code>类型。这意味着，无论原始值是什么，都会被零位扩展为32位无符号整数。</li></ul><p>在处理<code>boolean</code>、<code>byte</code>、<code>short</code>和<code>char</code>类型的数组时，也会使用对应的<code>int</code>类型的字节码指令来进行操作。因此，实际上，大多数对于这些较小整数类型的操作，都是使用<code>int</code>类型作为运算类型来进行的。这种设计简化了字节码指令集，减少了复杂性。</p><h2 id="_2-2加载和存储指令" tabindex="-1"><a class="header-anchor" href="#_2-2加载和存储指令"><span>2.2加载和存储指令</span></a></h2><p>加载和存储指令在Java虚拟机中用于在栈帧的局部变量表和操作数栈之间传输数据。这些指令包括：</p><ul><li><p><strong>将一个局部变量加载到操作数栈：</strong></p><ul><li><code>iload</code>：将int类型的局部变量加载到操作数栈。</li><li><code>iload_&lt;n&gt;</code>：将int类型的局部变量加载到操作数栈，其中 <code>&lt;n&gt;</code> 表示局部变量索引，可以是0到3的数字。</li></ul><p>（类似的指令存在于其他数据类型，如<code>lload</code>、<code>fload</code>、<code>dload</code>、<code>aload</code>）</p></li><li><p><strong>将一个数值从操作数栈存储到局部变量表：</strong></p><ul><li><code>istore</code>：将int类型的数值存储到局部变量表。</li><li><code>istore_&lt;n&gt;</code>：将int类型的数值存储到局部变量表，其中 <code>&lt;n&gt;</code> 表示局部变量索引，可以是0到3的数字。</li></ul><p>（类似的指令存在于其他数据类型，如<code>lstore</code>、<code>fstore</code>、<code>dstore</code>、<code>astore</code>）</p></li><li><p><strong>将一个常量加载到操作数栈：</strong></p><ul><li><code>bipush</code>：将单字节常量（-128到127之间的整数）推送到操作数栈。</li><li><code>sipush</code>：将短整型常量（-32768到32767之间的整数）推送到操作数栈。</li><li><code>ldc</code>：将int、float或String类型的常量值从常量池中推送到操作数栈。</li><li><code>ldc_w</code>：与<code>ldc</code>类似，但用于更大的常量池索引。</li></ul><p>（其他指令用于加载更大的常量，如<code>ldc2_w</code>、<code>aconst_null</code>、<code>iconst_m1</code>、<code>iconst_&lt;i&gt;</code>、<code>lconst_&lt;l&gt;</code>、<code>fconst_&lt;f&gt;</code>、<code>dconst_&lt;d&gt;</code>）</p></li><li><p><strong>扩充局部变量表的访问索引的指令：</strong></p><ul><li><code>wide</code>：用于扩大对局部变量表的访问索引，通常与其他指令一起使用。</li></ul></li></ul><blockquote><p>一些指令的助记符以尖括号结尾，表示这是一组指令的特殊形式。例如，<code>iload_&lt;n&gt;</code> 表示了一组特殊的<code>iload</code>指令，其中 <code>&lt;n&gt;</code> 可以是0到3的数字。这些特殊指令省略了显式的操作数，因为操作数隐含在指令中。这些指令的语义与原生的通用指令完全一致。</p></blockquote><h2 id="_2-3运算指令" tabindex="-1"><a class="header-anchor" href="#_2-3运算指令"><span>2.3运算指令</span></a></h2><p>Java虚拟机的算术指令用于对两个操作数栈上的值进行特定运算，并将结果重新存入操作数栈顶。主要分为对整型数据和浮点型数据的运算，其中涵盖了加法、减法、乘法、除法、求余、取反、位移、按位或、按位与、按位异或、局部变量自增、比较等操作。</p><p>以下是具体的算术指令列表：</p><p><strong>整数运算指令（对应不同数据类型，如int、long）：</strong></p><ul><li>加法指令：<code>iadd</code>、<code>ladd</code></li><li>减法指令：<code>isub</code>、<code>lsub</code></li><li>乘法指令：<code>imul</code>、<code>lmul</code></li><li>除法指令：<code>idiv</code>、<code>ldiv</code></li><li>求余指令：<code>irem</code>、<code>lrem</code></li><li>取反指令：<code>ineg</code>、<code>lneg</code></li><li>位移指令：<code>ishl</code>、<code>ishr</code>、<code>iushr</code>、<code>lshl</code>、<code>lshr</code>、<code>lushr</code></li><li>按位或指令：<code>ior</code>、<code>lor</code></li><li>按位与指令：<code>iand</code>、<code>land</code></li><li>按位异或指令：<code>ixor</code>、<code>lxor</code></li><li>局部变量自增指令：<code>iinc</code></li><li>比较指令：<code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code></li></ul><p><strong>浮点数运算指令（对应不同数据类型，如float、double）：</strong></p><ul><li>加法指令：<code>fadd</code>、<code>dadd</code></li><li>减法指令：<code>fsub</code>、<code>dsub</code></li><li>乘法指令：<code>fmul</code>、<code>dmul</code></li><li>除法指令：<code>fdiv</code>、<code>ddiv</code></li><li>求余指令：<code>frem</code>、<code>drem</code></li><li>取反指令：<code>fneg</code>、<code>dneg</code></li></ul><blockquote><p>在整型数据溢出的情况下，虚拟机规范并未定义具体的结果，只有在除法和求余指令中当除数为零时会抛出<code>ArithmeticException</code>异常。对于浮点数运算，虚拟机要求遵循IEEE 754规范，包括对非正规浮点数值和逐级下溢的运算规则。</p><p>在对long类型数值进行比较时，采用带符号的比较方式；而对浮点数值进行比较时，采用IEEE 754规范中的无信号比较方式。</p><p>如果某个操作结果没有明确的数学定义的话， 将会使用NaN（Not a Number）值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p><p>这些规定确保了在Java虚拟机中进行数值运算时，结果是符合预期并具有可靠性的。</p></blockquote><h2 id="_2-4类型转换指令" tabindex="-1"><a class="header-anchor" href="#_2-4类型转换指令"><span>2.4类型转换指令</span></a></h2><p>类型转换指令用于将两种不同的数值类型相互转换，主要分为宽化类型转换（Widening Numeric Conversion）和窄化类型转换（Narrowing Numeric Conversion）两种。</p><p>Java虚拟机直接支持宽化类型转换，即将小范围类型向大范围类型进行安全转换。例如：</p><ul><li>将int类型转换为long、float或double类型</li><li>将long类型转换为float或double类型</li><li>将float类型转换为double类型</li></ul><p>窄化类型转换必须显式地使用转换指令完成，包括：</p><ul><li><code>i2b</code>：将int类型转换为byte类型</li><li><code>i2c</code>：将int类型转换为char类型</li><li><code>i2s</code>：将int类型转换为short类型</li><li><code>l2i</code>：将long类型转换为int类型</li><li><code>f2i</code>：将float类型转换为int类型</li><li><code>f2l</code>：将float类型转换为long类型</li><li><code>d2i</code>：将double类型转换为int类型</li><li><code>d2l</code>：将double类型转换为long类型</li><li><code>d2f</code>：将double类型转换为float类型</li></ul><p>窄化类型转换可能导致转换结果的正负号变化以及数值的精度丢失。在浮点数值窄化转换为整数类型时，需遵循一定规则，如对NaN的处理和使用IEEE 754的向零舍入模式取整。虚拟机规范明确规定数值类型的窄化转换指令不会导致运行时异常。</p><p>这些规定确保了在Java虚拟机中进行数值类型转换时，能够预期并具有可靠性的结果。</p><h2 id="_2-5对象创建与访问指令" tabindex="-1"><a class="header-anchor" href="#_2-5对象创建与访问指令"><span>2.5对象创建与访问指令</span></a></h2><p>Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。以下是涉及对象创建和操作的一些指令：</p><p><strong>创建类实例的指令：</strong></p><ul><li><code>new</code>：创建一个新的类实例</li></ul><p><strong>创建数组的指令：</strong></p><ul><li><code>newarray</code>：创建一个基本类型数组</li><li><code>anewarray</code>：创建一个引用类型数组</li><li><code>multianewarray</code>：创建一个多维数组</li></ul><p><strong>访问类字段和实例字段的指令：</strong></p><ul><li><code>getfield</code>：获取实例字段的值</li><li><code>putfield</code>：设置实例字段的值</li><li><code>getstatic</code>：获取类字段（静态字段）的值</li><li><code>putstatic</code>：设置类字段（静态字段）的值</li></ul><p><strong>数组元素的加载和存储指令：</strong></p><ul><li><code>baload</code>：将一个byte或boolean数组元素加载到操作数栈</li><li><code>caload</code>：将一个char数组元素加载到操作数栈</li><li><code>saload</code>：将一个short数组元素加载到操作数栈</li><li><code>iaload</code>：将一个int数组元素加载到操作数栈</li><li><code>laload</code>：将一个long数组元素加载到操作数栈</li><li><code>faload</code>：将一个float数组元素加载到操作数栈</li><li><code>daload</code>：将一个double数组元素加载到操作数栈</li><li><code>aaload</code>：将一个引用类型数组元素加载到操作数栈</li><li><code>bastore</code>：将一个byte或boolean值存储到byte或boolean数组元素中</li><li><code>castore</code>：将一个char值存储到char数组元素中</li><li><code>sastore</code>：将一个short值存储到short数组元素中</li><li><code>iastore</code>：将一个int值存储到int数组元素中</li><li><code>lastore</code>：将一个long值存储到long数组元素中</li><li><code>fastore</code>：将一个float值存储到float数组元素中</li><li><code>dastore</code>：将一个double值存储到double数组元素中</li><li><code>aastore</code>：将一个引用类型值存储到引用类型数组元素中</li></ul><p><strong>数组长度的指令：</strong></p><ul><li><code>arraylength</code>：获取数组的长度</li></ul><p><strong>检查类实例类型的指令：</strong></p><ul><li><code>instanceof</code>：检查对象是否是某个类的实例</li><li><code>checkcast</code>：检查对象是否可以强制转换为指定类型</li></ul><h2 id="_2-6操作数栈管理指令" tabindex="-1"><a class="header-anchor" href="#_2-6操作数栈管理指令"><span>2.6操作数栈管理指令</span></a></h2><p>Java虚拟机提供了一些指令，用于直接操作操作数栈。这些指令包括：</p><p><strong>将操作数栈的栈顶一个或两个元素出栈：</strong></p><ul><li><code>pop</code>：将栈顶一个元素弹出</li><li><code>pop2</code>：将栈顶两个元素弹出</li></ul><p><strong>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：</strong></p><ul><li><code>dup</code>：复制栈顶一个元素并将复制值重新压入栈顶</li><li><code>dup2</code>：复制栈顶两个元素并将复制值或双份的复制值重新压入栈顶</li><li><code>dup_x1</code>：复制栈顶一个元素并将复制值与栈顶下面的元素互换位置，然后重新压入栈顶</li><li><code>dup2_x1</code>：复制栈顶两个元素并将复制值或双份的复制值与栈顶下面的元素互换位置，然后重新压入栈顶</li><li><code>dup_x2</code>：复制栈顶一个元素并将复制值与栈顶下面的两个元素互换位置，然后重新压入栈顶</li><li><code>dup2_x2</code>：复制栈顶两个元素并将复制值或双份的复制值与栈顶下面的两个元素互换位置，然后重新压入栈顶</li></ul><p><strong>将栈最顶端的两个数值互换：</strong></p><ul><li><code>swap</code>：将栈最顶端的两个元素互换位置</li></ul><h2 id="_2-7控制转移指令" tabindex="-1"><a class="header-anchor" href="#_2-7控制转移指令"><span>2.7控制转移指令</span></a></h2><p>控制转移指令在Java虚拟机中用于有条件或无条件地改变程序执行流程。这些指令包括：</p><p><strong>条件分支：</strong></p><ul><li><code>ifeq</code>：如果栈顶元素等于0，则跳转</li><li><code>iflt</code>：如果栈顶元素小于0，则跳转</li><li><code>ifle</code>：如果栈顶元素小于等于0，则跳转</li><li><code>ifne</code>：如果栈顶元素不等于0，则跳转</li><li><code>ifgt</code>：如果栈顶元素大于0，则跳转</li><li><code>ifge</code>：如果栈顶元素大于等于0，则跳转</li><li><code>ifnull</code>：如果栈顶元素为null，则跳转</li><li><code>ifnonnull</code>：如果栈顶元素不为null，则跳转</li><li><code>if_icmpeq</code>：如果栈顶两个int型元素相等，则跳转</li><li><code>if_icmpne</code>：如果栈顶两个int型元素不相等，则跳转</li><li><code>if_icmplt</code>：如果栈顶两个int型元素第一个小于第二个，则跳转</li><li><code>if_icmpgt</code>：如果栈顶两个int型元素第一个大于第二个，则跳转</li><li><code>if_icmple</code>：如果栈顶两个int型元素第一个小于等于第二个，则跳转</li><li><code>if_icmpge</code>：如果栈顶两个int型元素第一个大于等于第二个，则跳转</li><li><code>if_acmpeq</code>：如果栈顶两个引用类型元素相等，则跳转</li><li><code>if_acmpne</code>：如果栈顶两个引用类型元素不相等，则跳转</li></ul><p><strong>复合条件分支：</strong></p><ul><li><code>tableswitch</code>：通过索引访问表格来进行跳转，用于switch语句的实现</li><li><code>lookupswitch</code>：通过键值对访问表格来进行跳转，用于switch语句的实现</li></ul><p><strong>无条件分支：</strong></p><ul><li><code>goto</code>：无条件跳转</li><li><code>goto_w</code>：无条件跳转（宽索引）</li><li><code>jsr</code>：跳转到子例程（调用子例程）</li><li><code>jsr_w</code>：跳转到子例程（调用子例程，宽索引）</li><li><code>ret</code>：返回子例程</li></ul><blockquote><p>宽索引是使用4个字节而不是标准的1个字节来表示跳转目标的偏移量。这使得这两个指令能够处理更大范围的代码偏移，允许跳转到更远的位置。</p></blockquote><h2 id="_2-8方法调用和返回指令" tabindex="-1"><a class="header-anchor" href="#_2-8方法调用和返回指令"><span>2.8方法调用和返回指令</span></a></h2><p>在Java虚拟机的指令集中，方法调用是通过一系列不同的指令完成的，这些指令涵盖了不同类型的方法调用。以下是五个主要的方法调用指令：</p><ol><li><p><strong>invokevirtual指令：</strong></p><ul><li>用于调用对象的实例方法。</li><li>根据对象的实际类型进行分派，这是虚方法分派的典型方式。</li><li>是Java语言中最常见的方法分派方式。</li></ul><blockquote><p>虚方法分派（Virtual Method Dispatch）是指在面向对象编程中，根据对象的实际类型（运行时类型）来确定调用哪个版本的方法。这种分派方式主要用于处理多态性，确保在运行时调用的是对象实际所属类的方法，而不是编译时所声明的类型。</p><p>是面向对象编程中实现多态的重要机制之一。</p></blockquote></li><li><p><strong>invokeinterface指令：</strong></p><ul><li>用于调用接口方法。</li><li>在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li></ul></li><li><p><strong>invokespecial指令：</strong></p><ul><li>用于调用一些需要特殊处理的实例方法。</li><li>包括实例初始化方法、私有方法和父类方法。</li></ul></li><li><p><strong>invokestatic指令：</strong></p><ul><li>用于调用类静态方法（static方法）。</li></ul></li><li><p><strong>invokedynamic指令：</strong></p><ul><li>用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。</li><li>与前四条调用指令不同，invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul></li></ol><p>方法调用指令与数据类型无关。方法的返回操作则根据返回值的类型有不同的指令，包括：</p><ul><li><code>ireturn</code>（用于返回boolean、byte、char、short和int类型的值），</li><li><code>lreturn</code>（long类型的值），</li><li><code>freturn</code>（float类型的值），</li><li><code>dreturn</code>（double类型的值），</li><li><code>areturn</code>（引用类型的值）。</li></ul><p>此外，还有一条<code>return</code>指令，供声明为void的方法、实例初始化方法、类和接口的类初始化方法使用。</p><h2 id="_2-9异常处理指令" tabindex="-1"><a class="header-anchor" href="#_2-9异常处理指令"><span>2.9异常处理指令</span></a></h2><p>在Java虚拟机中，<code>athrow</code> 指令用于显式抛出异常。当在程序中使用 <code>throw</code> 语句时，编译器会将相应的异常对象推送到操作数栈顶，然后通过 <code>athrow</code> 指令将异常抛出。<code>athrow</code> 指令的使用类似于其他指令，只不过它专门用于抛出异常。</p><p>异常处理（catch语句）不是由特定的字节码指令来实现的，而是通过异常表（Exception Table）来完成。异常表是一种数据结构，用于在方法的字节码中记录异常处理器的信息，包括受监控的范围、捕获的异常类型以及对应的异常处理代码的起始位置等信息。</p><p>异常表的作用是在方法的字节码执行过程中，当发生异常时，虚拟机会根据异常表中的信息确定如何处理异常。以下是异常表的主要结构：</p><ul><li><strong>start_pc、end_pc：</strong> 定义了受监控范围的起始和结束位置。在这个范围内，如果发生异常，则按照异常表中的处理器信息进行处理。</li><li><strong>handler_pc：</strong> 指定了异常处理器的起始位置，即对应异常发生时要执行的代码的入口。</li><li><strong>catch_type：</strong> 指定了捕获的异常类型，是一个对常量池中CONSTANT_Class_info型常量的索引，表示捕获的异常类型。如果catch_type的值为0，表示捕获所有类型的异常（相当于Java中的<code>catch(Exception e)</code>）。</li></ul><p>异常表中的每一项都对应着一个异常处理器，Java虚拟机在发现异常时会遍历异常表，找到第一个匹配的异常处理器，然后跳转到相应的处理代码块。如果没有找到匹配的异常处理器，那么异常将会传递到上层调用栈。</p><h2 id="_2-10同步指令" tabindex="-1"><a class="header-anchor" href="#_2-10同步指令"><span>2.10同步指令</span></a></h2><p>字节码指令在Java虚拟机中的执行是原子性的。每个字节码指令都被视为一个原子操作，它们要么完全执行，要么不执行。这种原子性保证了在多线程环境中，一个线程执行的字节码指令不会被其他线程中断或插入。</p><p>但是代码指令则为非原子性，例如读取和写入共享变量。在多线程环境下，为了确保线程安全，可能需要使用额外的同步机制。</p><p>因此，Java虚拟机支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都使用管程（Monitor，通常称为“锁”）来实现。</p><ul><li><p><strong>方法级的同步（隐式同步）：</strong> 方法级的同步是隐式的，无需通过字节码指令控制。虚拟机可以通过检查方法的访问标志（ACC_SYNCHRONIZED）来确定一个方法是否被声明为同步方法。</p><ul><li>当调用同步方法时，调用指令检查方法的访问标志，如果设置了，执行线程要求首先成功持有管程（锁），然后才能执行方法。最后，在方法完成时，无论是正常完成还是非正常完成，都会释放管程。</li><li>在同步方法执行期间，执行线程持有管程，其他线程无法获取相同的管程。如果同步方法执行期间抛出异常，并且在方法内部无法处理此异常，同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</li></ul></li><li><p><strong>同步一段指令序列：</strong> 同步一段指令序列通常由Java语言中的<code>synchronized</code>语句块表示。</p><ul><li>Java虚拟机提供了<code>monitorenter</code>和<code>monitorexit</code>两条指令来支持<code>synchronized</code>关键字的语义。</li><li>这种同步方式需要Javac编译器与Java虚拟机共同协作来支持，举例如下：</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span><span class="token class-name">Foo</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
	<span class="token keyword">synchronized</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
		<span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ 编译后，这段代码生成的字节码序列如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token class-name">Method</span> <span class="token keyword">void</span> <span class="token function">onlyMe</span><span class="token punctuation">(</span><span class="token class-name">Foo</span><span class="token punctuation">)</span>
<span class="token number">0</span> aload_1          <span class="token comment">// 将对象f入栈</span>
<span class="token number">1</span> dup              <span class="token comment">// 复制栈顶元素（即f的引用）</span>
<span class="token number">2</span> astore_2         <span class="token comment">// 将栈顶元素存储到局部变量表变量槽2中</span>
<span class="token number">3</span> monitorenter     <span class="token comment">// 以栈顶元素（即f）作为锁，开始同步</span>
<span class="token number">4</span> aload_0          <span class="token comment">// 将局部变量槽0（即this指针）的元素入栈</span>
<span class="token number">5</span> invokevirtual #<span class="token number">5</span> <span class="token comment">// 调用doSomething()方法</span>
<span class="token number">8</span> aload_2          <span class="token comment">// 将局部变量槽2的元素（即f）入栈</span>
<span class="token number">9</span> monitorexit      <span class="token comment">// 退出同步</span>
<span class="token number">10</span> <span class="token keyword">goto</span> <span class="token number">18</span>         <span class="token comment">// 方法正常结束，跳转到18返回</span>

<span class="token number">13</span> astore_3        <span class="token comment">// 从这步开始是异常路径，见下面异常表的Target</span>
<span class="token number">14</span> aload_2          <span class="token comment">// 将局部变量槽2的元素（即f）入栈</span>
<span class="token number">15</span> monitorexit      <span class="token comment">// 退出同步</span>
<span class="token number">16</span> aload_3          <span class="token comment">// 将局部变量槽3的元素（即异常对象）入栈</span>
<span class="token number">17</span> athrow           <span class="token comment">// 把异常对象重新抛出给onlyMe()方法的调用者</span>

<span class="token number">18</span> <span class="token keyword">return</span>          <span class="token comment">// 方法正常返回</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/JVM学习-Class文件结构/2023/12/14/dd2bd4ebcbef6bfa443a517c391b58a0.png" alt="image-20231117200044252" style="zoom:50%;"><p>为了保证在方法异常完成时monitorenter和monitorexit指 令依然可以正确配对执行，编译器会自动产生一个异常处理程序，这个异常处理程序声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p></li></ul><h1 id="三、公有设计、私有实现" tabindex="-1"><a class="header-anchor" href="#三、公有设计、私有实现"><span>三、公有设计、私有实现</span></a></h1><p>Java虚拟机规范对于Java程序与虚拟机实现之间的关系的规定。它明确了虚拟机实现者在设计虚拟机时的自由度和灵活性。一些关键点包括：</p><ul><li><strong>公有设计与私有实现之分界线：</strong> Java虚拟机规范定义了Java虚拟机应有的共同程序存储格式（Class文件格式）和字节码指令集。这些规范为Java平台上的不同实现提供了一个通用的交互手段。规范强调了实现者可以灵活地在实现中进行优化和修改，只要保持对Class文件的正确读取和包含在其中的语义的准确实现。</li><li><strong>实现的伸缩性：</strong> 实现者可以根据虚拟机的目标和关注点选择不同的实现方式。这包括将Java虚拟机代码翻译成另一种虚拟机的指令集或将其翻译成宿主机处理程序的本地指令集。这种伸缩性使得虚拟机可以在性能、内存消耗和可移植性等方面进行权衡和优化。</li><li><strong>即时编译器（Just-In-Time Compiler）等例外情况：</strong> 在某些情况下，一些工具如调试器、性能监视器和即时编译器可能需要访问一些通常被认为是虚拟机后台的元素，这可能对实现者的自由度产生一些限制。</li></ul><blockquote><p>虚拟机实现者有很大的灵活性来调整实现以提高性能、降低内存消耗或实现其他目标，同时保持对Java虚拟机规范的兼容性。这种设计理念为不同的Java虚拟机实现提供了空间，以满足各种不同的需求。</p></blockquote><h1 id="四、class文件结构的发展" tabindex="-1"><a class="header-anchor" href="#四、class文件结构的发展"><span>四、Class文件结构的发展</span></a></h1><p>Class文件结构在Java技术体系中具有稳定性和可扩展性。以下是一些重要的观点：</p><ul><li><strong>Class文件结构的稳定性：</strong> 自《Java虚拟机规范》初版订立以来，Class文件结构已经有二十多年的历史。在这段时间里，尽管Java技术体系发生了巨大的改变，包括语言、API等方面的变化，但是Class文件结构一直保持相对稳定，主体结构和字节码指令的语义和数量几乎没有变动。</li><li><strong>对访问标志和属性表的改进：</strong> 随着Java技术的演进，Class文件的访问标志和属性表也进行了一些改进。访问标志新增了一些标志，如ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_BRIDGE、ACC_VARARGS。属性表集合中新增了一系列属性，主要用于支持新的语言特性，如枚举、变长参数、泛型、动态注解等，以及为了性能改进和调试信息。</li><li><strong>平台中立和可扩展性的重要性：</strong> Class文件格式具有平台中立、紧凑、稳定和可扩展的特点，这是实现Java技术体系中平台无关和语言无关两项特性的关键支柱。这种设计使得Java程序可以在不同的硬件和操作系统上运行，同时为未来的语言特性和扩展提供了空间。</li></ul><blockquote><p>二十余年间，字节码的数量和语义只发生过屈指可数的几次变动，例如JDK1.0.2时改动过invokespecial指令的语义，JDK 7增加了invokedynamic指令，禁止了ret和jsr指令。</p></blockquote>`,79);function i(c,r){return d(),a("div",null,[l,n(" Java虚拟机的字节码指令集并没有提供专门用于处理整数类型`byte`、`char`和`short`以及布尔类型(`boolean`)的指令。相反，编译器在编译期或运行期进行类型转换，将这些较小的整数类型转换为`int`类型，然后使用`int`类型的字节码指令来进行操作。 "),s])}const g=e(o,[["render",i],["__file","JVM学习-Class文件结构.html.vue"]]),h=JSON.parse('{"path":"/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html","title":"文件结构","lang":"zh-CN","frontmatter":{"title":"文件结构","icon":"lightbulb","description":"文章原文：https://gaoyubo.cn/blogs/844dc0e7.html 一、Class类文件的结构 任何一个Class文件都对应着唯一的一个类或接口的定义信息。 但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。 Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%AD%A6%E4%B9%A0-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84.html"}],["meta",{"property":"og:site_name","content":"疼了也不哭"}],["meta",{"property":"og:title","content":"文件结构"}],["meta",{"property":"og:description","content":"文章原文：https://gaoyubo.cn/blogs/844dc0e7.html 一、Class类文件的结构 任何一个Class文件都对应着唯一的一个类或接口的定义信息。 但是反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。 Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据项目严格按..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"文件结构\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"示例","slug":"示例","link":"#示例","children":[]},{"level":2,"title":"1.1魔数与版本号","slug":"_1-1魔数与版本号","link":"#_1-1魔数与版本号","children":[]},{"level":2,"title":"1.2常量池","slug":"_1-2常量池","link":"#_1-2常量池","children":[]},{"level":2,"title":"1.3访问标志","slug":"_1-3访问标志","link":"#_1-3访问标志","children":[]},{"level":2,"title":"1.4类索引、父类索引与接口索引","slug":"_1-4类索引、父类索引与接口索引","link":"#_1-4类索引、父类索引与接口索引","children":[{"level":3,"title":"类索引（this_class）和父类索引（super_class）","slug":"类索引-this-class-和父类索引-super-class","link":"#类索引-this-class-和父类索引-super-class","children":[]},{"level":3,"title":"接口索引集合（interfaces）","slug":"接口索引集合-interfaces","link":"#接口索引集合-interfaces","children":[]},{"level":3,"title":"class文件中示例","slug":"class文件中示例","link":"#class文件中示例","children":[]}]},{"level":2,"title":"1.5字段表集合","slug":"_1-5字段表集合","link":"#_1-5字段表集合","children":[{"level":3,"title":"简单描述和描述符（name_index和descriptor_index）","slug":"简单描述和描述符-name-index和descriptor-index","link":"#简单描述和描述符-name-index和descriptor-index","children":[]},{"level":3,"title":"属性表","slug":"属性表","link":"#属性表","children":[]},{"level":3,"title":"字段表集合的特性","slug":"字段表集合的特性","link":"#字段表集合的特性","children":[]},{"level":3,"title":"class文件中示例","slug":"class文件中示例-1","link":"#class文件中示例-1","children":[]}]},{"level":2,"title":"1.6方法表集合","slug":"_1-6方法表集合","link":"#_1-6方法表集合","children":[{"level":3,"title":"方法表的访问标志","slug":"方法表的访问标志","link":"#方法表的访问标志","children":[]},{"level":3,"title":"class文件中示例","slug":"class文件中示例-2","link":"#class文件中示例-2","children":[]}]},{"level":2,"title":"1.7属性表集合","slug":"_1-7属性表集合","link":"#_1-7属性表集合","children":[{"level":3,"title":"Code属性","slug":"code属性","link":"#code属性","children":[]},{"level":3,"title":"Exceptions属性","slug":"exceptions属性","link":"#exceptions属性","children":[]},{"level":3,"title":"LineNumberTable 属性","slug":"linenumbertable-属性","link":"#linenumbertable-属性","children":[]},{"level":3,"title":"LocalVariableTable 属性","slug":"localvariabletable-属性","link":"#localvariabletable-属性","children":[]},{"level":3,"title":"SourceFile 属性","slug":"sourcefile-属性","link":"#sourcefile-属性","children":[]},{"level":3,"title":"SourceDebugExtension 属性","slug":"sourcedebugextension-属性","link":"#sourcedebugextension-属性","children":[]}]},{"level":2,"title":"2.1字节码与数据类型","slug":"_2-1字节码与数据类型","link":"#_2-1字节码与数据类型","children":[]},{"level":2,"title":"2.2加载和存储指令","slug":"_2-2加载和存储指令","link":"#_2-2加载和存储指令","children":[]},{"level":2,"title":"2.3运算指令","slug":"_2-3运算指令","link":"#_2-3运算指令","children":[]},{"level":2,"title":"2.4类型转换指令","slug":"_2-4类型转换指令","link":"#_2-4类型转换指令","children":[]},{"level":2,"title":"2.5对象创建与访问指令","slug":"_2-5对象创建与访问指令","link":"#_2-5对象创建与访问指令","children":[]},{"level":2,"title":"2.6操作数栈管理指令","slug":"_2-6操作数栈管理指令","link":"#_2-6操作数栈管理指令","children":[]},{"level":2,"title":"2.7控制转移指令","slug":"_2-7控制转移指令","link":"#_2-7控制转移指令","children":[]},{"level":2,"title":"2.8方法调用和返回指令","slug":"_2-8方法调用和返回指令","link":"#_2-8方法调用和返回指令","children":[]},{"level":2,"title":"2.9异常处理指令","slug":"_2-9异常处理指令","link":"#_2-9异常处理指令","children":[]},{"level":2,"title":"2.10同步指令","slug":"_2-10同步指令","link":"#_2-10同步指令","children":[]}],"git":{},"readingTime":{"minutes":55.36,"words":16609},"filePathRelative":"book/深入理解Java虚拟机/JVM学习-Class文件结构.md","autoDesc":true}');export{g as comp,h as data};
