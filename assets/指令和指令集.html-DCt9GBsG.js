import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,d as e}from"./app-D1py-eEI.js";const t={},o=e(`<h2 id="字节码、class文件、指令集的关系" tabindex="-1"><a class="header-anchor" href="#字节码、class文件、指令集的关系"><span>字节码、class文件、指令集的关系</span></a></h2><h3 id="class文件-二进制-和字节码-十六进制-的关系" tabindex="-1"><a class="header-anchor" href="#class文件-二进制-和字节码-十六进制-的关系"><span>class文件（二进制）和字节码（十六进制）的关系</span></a></h3><p>class文件</p><ul><li><p>经过编译器编译后的文件（如javac），一个class文件代表一个类或者接口；</p></li><li><p>是由字节码组成的，主要存储的是字节码，字节码是访问jvm的重要指令</p></li><li><p>文件本身是2进制，对应的是16进制的数。</p></li></ul><p>字节码</p><ul><li><p>包括<code>操作码（Opcode）</code>和<code>操作数</code>：操作码是一个字节</p></li><li><p>如果方法不是抽象的，也不是本地方法，方法的Java代码就会被编译器编译成字节码，存放在method_info结构的Code属性中</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/Golang实现JAVA虚拟机-指令集和解释器/2023/12/14/91a5e2b50c5ae272662185826be353ba.png" alt="" style="zoom:80%;"></li></ul><p>如图：操作码为B2，助记符为助记符是<code>getstatic</code>。它的操作数是0x0002，代表常量池里的第二个常量。</p><p>操作数栈和局部变量表只存放数据的值， 并不记录数据类型。<strong>结果就是：指令必须知道自己在操作什么类型的数据。</strong></p><p>这一点也直接反映在了操作码的<code>助记符</code>上。</p><blockquote><p>例如，iadd指令：对int值进行加法操作； dstore指令：把操作数栈顶的double值弹出，存储到局部变量表中； areturn：从方法中返回引用值。</p></blockquote><h3 id="助记符" tabindex="-1"><a class="header-anchor" href="#助记符"><span>助记符</span></a></h3><p>如果某类指令可以操作不同类型的变量，则助记符的第一个字母表示变量类型。助记符首字母和变量类型的对应关系如下：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/Golang实现JAVA虚拟机-指令集和解释器/2023/12/14/623404837100ad6fefbc2d2e707f2972.png" alt="" style="zoom:80%;"><h3 id="指令分类" tabindex="-1"><a class="header-anchor" href="#指令分类"><span>指令分类</span></a></h3><p>Java虚拟机规范把已经定义的205条指令按用途分成了11类， 分别是：</p><ul><li>常量（constants）指令</li><li>加载（loads）指令</li><li>存储（stores）指令</li><li>操作数栈（stack）指令</li><li>数学（math）指令</li><li>转换（conversions）指令</li><li>比较（comparisons）指令</li><li>控制（control）指令</li><li>引用（references）指令</li><li>扩展（extended）指令</li><li>保留（reserved）指令： <ul><li>操作码：202（0xCA），助记符：breakpoint，用于调试器的断点调试</li><li>254（0xFE），助记符：impdep1</li><li>266（0xFF），助记符：impdep2</li><li>这三条指令不允许出现在class文件中</li></ul></li></ul><p>本章将要实现的指令涉及11类中的9类</p><h2 id="jvm执行引擎" tabindex="-1"><a class="header-anchor" href="#jvm执行引擎"><span>JVM执行引擎</span></a></h2><p>执行引擎是Java虚拟机四大组成部分中一个核心组成（另外三个分别是<code>类加载器子系统</code>、<code>运行时数据区</code>、<code>垃圾回收器</code>），</p><blockquote><p>Java虚拟机的执行引擎主要是用来执行Java字节码。</p></blockquote><p>它有两种主要执行方式：通过<code>字节码解释器</code>执行，通过<code>即时编译器</code>执行</p><h3 id="解释和编译" tabindex="-1"><a class="header-anchor" href="#解释和编译"><span>解释和编译</span></a></h3><p>在了解字节码解释器和即使编译器之前，需要先了解<code>解释</code>和<code>编译</code></p><ul><li>解释是将代码逐行或逐条指令地转换为机器代码并立即执行的方式，适合实现跨平台性。</li><li>编译是将整个程序或代码块翻译成机器代码的方式，生成的机器代码可反复执行，通常更快，但不具备跨平台性。</li></ul><h3 id="字节码解释器" tabindex="-1"><a class="header-anchor" href="#字节码解释器"><span>字节码解释器</span></a></h3><p>字节码解释器将逐条解释执行Java字节码指令。这意味着它会逐个读取字节码文件中的指令，并根据每个指令执行相应的操作。虽然解释执行相对较慢。</p><blockquote><p>逐行解释和执行代码。它会逐行读取源代码或字节码，将每一行翻译成计算机指令，然后立即执行该指令。</p><p>因此具有平台无关性，因为字节码可以在不同的平台上运行。</p></blockquote><h3 id="即时编译器-just-in-time-compiler-jit" tabindex="-1"><a class="header-anchor" href="#即时编译器-just-in-time-compiler-jit"><span>即时编译器（Just-In-Time Compiler，JIT）</span></a></h3><p>即时编译器将字节码编译成本地机器代码，然后执行本地代码。</p><blockquote><p>这种方式更快，因为它避免了字节码解释的过程，但编译需要一些时间。</p><p>即时编译器通常会选择性地编译某些热点代码路径，以提高性能。</p></blockquote><h3 id="解释器规范" tabindex="-1"><a class="header-anchor" href="#解释器规范"><span>解释器规范</span></a></h3><p>Java虚拟机规范的2.11节介绍了Java虚拟机解释器的大致逻辑，如下所示：</p><div class="language-c line-numbers-mode" data-ext="c" data-title="c"><pre class="language-c"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
    atomically calculate pc and fetch opcode at pc<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>operands<span class="token punctuation">)</span> fetch operands<span class="token punctuation">;</span>
    execute the action <span class="token keyword">for</span> the opcode<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>there is more to <span class="token keyword">do</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>从当前程序计数器（Program Counter，通常简称为 PC）中获取当前要执行的字节码指令的地址。</li><li>从该地址获取字节码指令的操作码（opcode），并执行该操作码对应的操作。</li><li>如果指令需要操作数（operands），则获取操作数。</li><li>执行指令对应的操作。</li><li>更新 PC，以便继续执行下一条字节码指令。</li><li>循环执行上述步骤，直到没有更多的指令需要执行。</li></ol><hr><p>每次循环都包含三个部分：计算pc、指令解码、指令执行</p><p>可以把这个逻辑用Go语言写成一个for循环，里面是个大大的<code>switch-case</code>语句。但这样的话，代码的可读性将非常差。</p><p>所以采用另外一种方式：把指令抽象成接口，解码和执行逻辑写在具体的指令实现中。</p><p>这样编写出的解释器就和Java虚拟机规范里的伪代码一样简单，伪代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">for</span> <span class="token punctuation">{</span>
    pc <span class="token operator">:=</span> <span class="token function">calculatePC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    opcode <span class="token operator">:=</span> bytecode<span class="token punctuation">[</span>pc<span class="token punctuation">]</span>
    inst <span class="token operator">:=</span> <span class="token function">createInst</span><span class="token punctuation">(</span>opcode<span class="token punctuation">)</span>
    inst<span class="token punctuation">.</span><span class="token function">fetchOperands</span><span class="token punctuation">(</span>bytecode<span class="token punctuation">)</span>
    inst<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="指令和指令解码" tabindex="-1"><a class="header-anchor" href="#指令和指令解码"><span>指令和指令解码</span></a></h2><p>本节先定义指令接口，然后定义一个结构体用来辅助指令解码</p><h3 id="instruction接口" tabindex="-1"><a class="header-anchor" href="#instruction接口"><span>Instruction接口</span></a></h3><p>为了便于管理，把每种指令的源文件都放在各自的包里，所有指令都共用的代码则放在<code>base包</code>里。</p><p>因此<code>instructions目录</code>下会有如下10个子目录：</p><img src="https://cdn.jsdelivr.net/gh/gaoyubo2/image/img/Golang实现JAVA虚拟机-指令集和解释器/2023/12/14/f37c7e3b8ebcb53d720acfc102fc6f26.png" alt="" style="zoom:80%;"><p><code>base目录</code>下创建<code>instruction.go</code>文件，在其中定义<code>Instruction接口</code>，代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> Instruction <span class="token keyword">interface</span> <span class="token punctuation">{</span>
    <span class="token function">FetchOperands</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span>
    <span class="token function">Execute</span><span class="token punctuation">(</span>frame <span class="token operator">*</span>rtda<span class="token punctuation">.</span>Frame<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>FetchOperands（）</code>方法从字节码中提取操作数，<code>Execute（）</code>方法执行指令逻辑。</p><p>有很多指令的操作数都是类似的。为了避免重复代码，按照操作数类型定义一些结构体，并实现<code>FetchOperands（）</code>方 法。</p><h4 id="无操作数指令" tabindex="-1"><a class="header-anchor" href="#无操作数指令"><span>无操作数指令</span></a></h4><p>在<code>instruction.go</code>文件中定义<code>NoOperandsInstruction</code>结构体，代码如下:</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> NoOperandsInstruction <span class="token keyword">struct</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>NoOperandsInstruction</code>表示没有操作数的指令，所以没有定义 任何字段。<code>FetchOperands（）</code>方法自然也是空空如也，什么也不用 读，代码如下:</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>NoOperandsInstruction<span class="token punctuation">)</span> <span class="token function">FetchOperands</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// nothing to do</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="跳转指令" tabindex="-1"><a class="header-anchor" href="#跳转指令"><span>跳转指令</span></a></h4><p>定义<code>BranchInstruction结构体</code>，代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> BranchInstruction <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">//偏移量</span>
	Offset <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>BranchInstruction</code>表示跳转指令，<code>Offset字段</code>存放跳转偏移量。</p><p><code>FetchOperands（）</code>方法从字节码中读取一个<code>uint16</code>整数，转成int后赋给<code>Offset字段</code>。代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>BranchInstruction<span class="token punctuation">)</span> <span class="token function">FetchOperands</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	self<span class="token punctuation">.</span>Offset <span class="token operator">=</span> <span class="token function">int</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">ReadInt16</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="存储和加载指令" tabindex="-1"><a class="header-anchor" href="#存储和加载指令"><span>存储和加载指令</span></a></h4><p>存储和加载类指令需要根据索引存取局部变量表，索引由单字节操作数给出。把这类指令抽象成<code>Index8Instruction结构体</code>，定义<code>Index8Instruction结构体</code>，代码如下:</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> Index8Instruction <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token comment">//索引</span>
    Index <span class="token builtin">uint</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>FetchOperands（）</code>方法从字节码中读取一个int8整数，转成<code>uint</code>后赋给<code>Index字段</code>。代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>Index8Instruction<span class="token punctuation">)</span> <span class="token function">FetchOperands</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	self<span class="token punctuation">.</span>Index <span class="token operator">=</span> <span class="token function">uint</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="访问常量池的指令" tabindex="-1"><a class="header-anchor" href="#访问常量池的指令"><span>访问常量池的指令</span></a></h4><p>有一些指令需要访问运行时常量池，<code>常量池索引</code>由两字节操作数给出，用<code>Index字段</code>表示常量池索引。定义<code>Index16Instruction结构体</code>，代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> Index16Instruction <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Index <span class="token builtin">uint</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>FetchOperands（）</code>方法从字节码中读取一个<code> uint16</code>整数，转成<code>uint</code>后赋给<code>Index字段</code>。代码如下</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>Index16Instruction<span class="token punctuation">)</span> <span class="token function">FetchOperands</span><span class="token punctuation">(</span>reader <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span>Index <span class="token operator">=</span> <span class="token function">uint</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">ReadUint16</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>指令接口和“抽象”指令定义好了，下面来看<code>BytecodeReader结构体</code></p><h3 id="bytecodereader结构体" tabindex="-1"><a class="header-anchor" href="#bytecodereader结构体"><span>BytecodeReader结构体</span></a></h3><p><code>base目录</code>下创建<code>bytecode_reader.go</code>文件，在 其中定义<code>BytecodeReader结构体</code></p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">type</span> BytecodeReader <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    code <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span> <span class="token comment">// bytecodes</span>
    pc   <span class="token builtin">int</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>code字段</code>存放字节码，pc字段记录读取到了哪个字节。</p><p>为了避免每次解码指令都新创建一个<code>BytecodeReader</code>实例，给它定义一个 <code>Reset（）</code>方法，代码如下:</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token function">Reset</span><span class="token punctuation">(</span>code <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> pc <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span>code <span class="token operator">=</span> code
    self<span class="token punctuation">.</span>pc <span class="token operator">=</span> pc
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>面实现一系列的<code>Read（）</code>方法。首先是最简单的<code>ReadUint8（）</code>方法，代码如下：</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>func (self *BytecodeReader) ReadUint8() uint8 {
    i := self.code[self.pc]
    self.pc++
    return i
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>从 <code>self.code</code> 字节切片中的 <code>self.pc</code> 位置读取一个字节（8 位）的整数值。</li><li>然后将 <code>self.pc</code> 的值增加1，以便下次读取下一个字节。</li><li>最后，返回读取的字节作为无符号 8 位整数</li></ul><p><code>ReadInt8（）</code>方法调用<code>ReadUint8（）</code>，然后把读取到的值转成<code>int8</code> 返回，代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token function">ReadInt8</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int8</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">int8</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ReadUint16（）</code>连续读取两字节</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token function">ReadUint16</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">uint16</span> <span class="token punctuation">{</span>
    byte1 <span class="token operator">:=</span> <span class="token function">uint16</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    byte2 <span class="token operator">:=</span> <span class="token function">uint16</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>byte1 <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> byte2
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ReadInt16（）</code>方法调用<code>ReadUint16（）</code>，然后把读取到的值转成 <code>int16</code>返回，代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token function">ReadInt16</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int16</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">int16</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint16</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ReadInt32（）</code>方法连续读取4字节，代码如下：</p><div class="language-go line-numbers-mode" data-ext="go" data-title="go"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>self <span class="token operator">*</span>BytecodeReader<span class="token punctuation">)</span> <span class="token function">ReadInt32</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int32</span> <span class="token punctuation">{</span>
    byte1 <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    byte2 <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    byte3 <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    byte4 <span class="token operator">:=</span> <span class="token function">int32</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span><span class="token function">ReadUint8</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>byte1 <span class="token operator">&lt;&lt;</span> <span class="token number">24</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>byte2 <span class="token operator">&lt;&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>byte3 <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> byte4
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在接下来的小节中，将按照分类依次实现约150条指令，占整个指令集的3/4</p>`,90),p=[o];function c(i,l){return s(),a("div",null,p)}const r=n(t,[["render",c],["__file","指令和指令集.html.vue"]]),k=JSON.parse('{"path":"/book/Go%E5%AE%9E%E7%8E%B0Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/%E6%8C%87%E4%BB%A4%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86.html","title":"指令和指令集","lang":"zh-CN","frontmatter":{"title":"指令和指令集","order":1,"description":"字节码、class文件、指令集的关系 class文件（二进制）和字节码（十六进制）的关系 class文件 经过编译器编译后的文件（如javac），一个class文件代表一个类或者接口； 是由字节码组成的，主要存储的是字节码，字节码是访问jvm的重要指令 文件本身是2进制，对应的是16进制的数。 字节码 包括操作码（Opcode）和操作数：操作码是一个字...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/book/Go%E5%AE%9E%E7%8E%B0Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%8C%87%E4%BB%A4%E9%9B%86%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8/%E6%8C%87%E4%BB%A4%E5%92%8C%E6%8C%87%E4%BB%A4%E9%9B%86.html"}],["meta",{"property":"og:site_name","content":"疼了也不哭"}],["meta",{"property":"og:title","content":"指令和指令集"}],["meta",{"property":"og:description","content":"字节码、class文件、指令集的关系 class文件（二进制）和字节码（十六进制）的关系 class文件 经过编译器编译后的文件（如javac），一个class文件代表一个类或者接口； 是由字节码组成的，主要存储的是字节码，字节码是访问jvm的重要指令 文件本身是2进制，对应的是16进制的数。 字节码 包括操作码（Opcode）和操作数：操作码是一个字..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Mr.Hope"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"指令和指令集\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Hope\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"字节码、class文件、指令集的关系","slug":"字节码、class文件、指令集的关系","link":"#字节码、class文件、指令集的关系","children":[{"level":3,"title":"class文件（二进制）和字节码（十六进制）的关系","slug":"class文件-二进制-和字节码-十六进制-的关系","link":"#class文件-二进制-和字节码-十六进制-的关系","children":[]},{"level":3,"title":"助记符","slug":"助记符","link":"#助记符","children":[]},{"level":3,"title":"指令分类","slug":"指令分类","link":"#指令分类","children":[]}]},{"level":2,"title":"JVM执行引擎","slug":"jvm执行引擎","link":"#jvm执行引擎","children":[{"level":3,"title":"解释和编译","slug":"解释和编译","link":"#解释和编译","children":[]},{"level":3,"title":"字节码解释器","slug":"字节码解释器","link":"#字节码解释器","children":[]},{"level":3,"title":"即时编译器（Just-In-Time Compiler，JIT）","slug":"即时编译器-just-in-time-compiler-jit","link":"#即时编译器-just-in-time-compiler-jit","children":[]},{"level":3,"title":"解释器规范","slug":"解释器规范","link":"#解释器规范","children":[]}]},{"level":2,"title":"指令和指令解码","slug":"指令和指令解码","link":"#指令和指令解码","children":[{"level":3,"title":"Instruction接口","slug":"instruction接口","link":"#instruction接口","children":[]},{"level":3,"title":"BytecodeReader结构体","slug":"bytecodereader结构体","link":"#bytecodereader结构体","children":[]}]}],"git":{},"readingTime":{"minutes":7.9,"words":2370},"filePathRelative":"book/Go实现Java虚拟机/指令集和解释器/指令和指令集.md","autoDesc":true}');export{r as comp,k as data};
